{"posts":[{"title":"DavinciCTF 2023 Write-ups","text":"Giải DaVinciCTF năm nay mình giải được 4 bài Crypto, trong đó có 2 bài dễ không mất thời gian, và 2 bài còn lại về trao đổi khóa DHKE mình giải ra khi sắp hết giờ. Những bài này đều là những bài hay, phải dựa vào hint ẩn mà bài nhắc đến để giải. Welcome Welcome to the DaVinciCTF! Join the discord: https://discord.gg/JN8JPcH3Yn CryptoVigenere XOR (easy, 100) Leonard forgot to tell you the key he used to encrypt his message.Would you be able to recover the message he sent you ?Files: messageFlag format: dvCTF{[REDACTED]} found in the message message100011010001111010100110001110000001100000101100100100111011100100101000000100100011101010001000000010111001110100101110001110000001100100101110000100010001101010001100100111001001001110001000000100111001001000111101000000100000100100100101101111011011000100110101101100011000100000110111100001000011000010110000000001111011001010000010100011100000110010000101000001001000010110111110100011010000011010111111100000010011001010000001100001101000101100100010001111110011101000110011100100110001111100101010101110000001100000101111100101101001101110001100101110001 Cũng chẳng có gì khó, vào trang web này và brute thôi. 1You did it! The flag is dvCTF{80R3D_K3Y_15_K3Y_MY_FR13ND}. Well done ! Desintegrated RSA (crypto, 100) Leonard is starting to fell his age and his sight hasn’t been improving lately…He gave me a part of his private key to decipher a message he received but he must have written 2 bits wrongely.Would you be able to recover the private key for me and decipher his message please ?Files: my_paperFlag format: ASCII charsDon’t forget to add the dvCTF{} wrapper to your flag! my_paper1234e = 65537N = 717112095603796567459186675289085366666353307185490838112863469094236267064115095991318914077602556259092980640688481403957314611778356606590630923532172479459611664646123086735269849900884971954345014685854404613997971637479029358038777738612361656852669461942050483312357280227014477564862706358220265665684528484015675504406503642979068426662169208465726918109620002278730736582232507060863895239183614060352797915536803003766379326547455483805121183179622890875770347638754708633078401281869506937834987783549345444254985895168452303800618033133228421198570487293819512418570281720722209228656211732340633248821599038100558406541752556869957692270681816412540575428707774563875539462996182209726292786035178337626465674172053275188702251252357574867926706930607919671904054905671307852875045332721950531335900880364093157198125415400056706443026713461092993702796866382626321181134825237204434544098170777248711033815662904232551373912160599351955643630688486881346494419969742967490139650172842016964428670057727847565045461509019920640425372258450235773976492903639059374783281230558894906358850621988779071303812061651368357729631671532668073611308975396088608980146647649154262885567149667654346594998380255328428626713577833message = 264534650266105599806294021070614230595616525906055753733761719275657774871470140716982224248591199930143393536112109666634675797148303913100693807661342308555939532608805045967956383107966177699787072449920253895221304428097068425393162931376216861878624593868623806403407463235780480244748078241725783430590495340799442724682566190632050547591341323688977303501641184951367816544042508488494475499053434594879307412981360853044625476334885351799592910757244150652389450722949077045473797563111265917765609352389143140723484112393593857707133580845664021986531624981054608271428875875563984105161439320613210497589395084708184226072788120184187653476835755855473119021530837541643055886076234084972648710196573106365229553050082479821148344623946637161759377216826589918124913366632162149006381730172591022803075404878808812491011198771709647073141166756215048339139472055570431392757757451548399461407884147879477545478028761274883498759069612591413321559799628662445755512999075034030583300601150472018816567707188341247953317752726136118637093294082860094619153110729803351873487926928582227569644123629745035652271651297427589546895153366652555770618092604114490238897158877913219257369176494787069733353644783317504411523314154p = &quot;11001101110001101010110000010000100000101010010111101000000101001100011101101101101111100100111100010111010110010110011101100110100001100001001011011010101010110111111001001000100000110100011011001111101101110001101010111101011111011111011111110111110001101100001101101101101011001111100000110100101110101111000001010001011011011101001001111010001101000011110010110101111011101011001001101111111010111100001111001001001001100011001111001000000000000001100100100010010101100111010101010000010100010001010100101111101110111011100111101000110001010110010111000000000101111001100000110100001101101101100010000001010100100001111001000010001111110110010000001011001111111111111100010011100001010011110100111111000110110011000000111111110010000100001111110001000000111011000000100010001001011000110011100110111111000011111100110111001110111011010100000110110100010010110101001100111010101111011000000010011000000011000001100101000001110011101111110011001000001001001011111011000010100000110000001001100110101101000000001110111111000011000001111000111010001010110000001101000011000110000110000101000111001000001111111101101111000100100101111001110100111001100001011110010011110110101100000010110001110110110010010100000111000100010101111110010011010001100110101110100001000111101110101000011110000111110100110111010001100000100111001100111100011001101010101100011110001011100100111000010110100111010111101011001101000110010000110110011011010111111011110101100000100111101011110001111011010001000011001100000101011100011100000001100110011011110101101111110101100101110100101011110001111100010110000111111011011101000000000101010000100101110100100011000101100011001011001100111101101000000111111110111110011100001000110011100010100010011111100011110101010001101111100001101100000011101101110100100000011110111000010100000110111010111101101011011010111111010100101110111110100110110101011000010010110110111100001000010110000110000100001100011110111110101101010011001111011001011101000111001000001011001111100010010111111001111011000110001000011100101001100011&quot; Chỉ đơn giản là chọn 2 bytes bất kỳ và flip lại. Cũng không có gì. 1234567891011N = 717112095603796567459186675289085366666353307185490838112863469094236267064115095991318914077602556259092980640688481403957314611778356606590630923532172479459611664646123086735269849900884971954345014685854404613997971637479029358038777738612361656852669461942050483312357280227014477564862706358220265665684528484015675504406503642979068426662169208465726918109620002278730736582232507060863895239183614060352797915536803003766379326547455483805121183179622890875770347638754708633078401281869506937834987783549345444254985895168452303800618033133228421198570487293819512418570281720722209228656211732340633248821599038100558406541752556869957692270681816412540575428707774563875539462996182209726292786035178337626465674172053275188702251252357574867926706930607919671904054905671307852875045332721950531335900880364093157198125415400056706443026713461092993702796866382626321181134825237204434544098170777248711033815662904232551373912160599351955643630688486881346494419969742967490139650172842016964428670057727847565045461509019920640425372258450235773976492903639059374783281230558894906358850621988779071303812061651368357729631671532668073611308975396088608980146647649154262885567149667654346594998380255328428626713577833p = int(&quot;11001101110001101010110000010000100000101010010111101000000101001100011101101101101111100100111100010111010110010110011101100110100001100001001011011010101010110111111001001000100000110100011011001111101101110001101010111101011111011111011111110111110001101100001101101101101011001111100000110100101110101111000001010001011011011101001001111010001101000011110010110101111011101011001001101111111010111100001111001001001001100011001111001000000000000001100100100010010101100111010101010000010100010001010100101111101110111011100111101000110001010110010111000000000101111001100000110100001101101101100010000001010100100001111001000010001111110110010000001011001111111111111100010011100001010011110100111111000110110011000000111111110010000100001111110001000000111011000000100010001001011000110011100110111111000011111100110111001110111011010100000110110100010010110101001100111010101111011000000010011000000011000001100101000001110011101111110011001000001001001011111011000010100000110000001001100110101101000000001110111111000011000001111000111010001010110000001101000011000110000110000101000111001000001111111101101111000100100101111001110100111001100001011110010011110110101100000010110001110110110010010100000111000100010101111110010011010001100110101110100001000111101110101000011110000111110100110111010001100000100111001100111100011001101010101100011110001011100100111000010110100111010111101011001101000110010000110110011011010111111011110101100000100111101011110001111011010001000011001100000101011100011100000001100110011011110101101111110101100101110100101011110001111100010110000111111011011101000000000101010000100101110100100011000101100011001011001100111101101000000111111110111110011100001000110011100010100010011111100011110101010001101111100001101100000011101101110100100000011110111000010100000110111010111101101011011010111111010100101110111110100110110101011000010010110110111100001000010110000110000100001100011110111110101101010011001111011001011101000111001000001011001111100010010111111001111011000110001000011100101001100011&quot;, 2)for i in range(1, 2046): for j in range(i + 1, 2047): t = (1 &lt;&lt; i) ^ (1 &lt;&lt; j) s = p ^ t if N % s == 0: print(&quot;p = &quot;, s) exit(0) 1dvCTF{L30n4rd_M19ht_B3_0ld_But_5t1ll_Cunn1n9} Personal key (easy, 484) Our technical team has been able to eavesdrop and recover a conversation between Leonard and his friend as well as the decryption algorithm they use. They even made it possible to send messages to his friend after the exchange.Moreover, we know from a reliable source that his friend tends to keep the same private key.Would you be able to recover the message he sent to Leonard previously ?Files: decrypt.pyUsage:python3 decrypt.py -k &lt;private_shared_key&gt; -iv &lt;iv&gt; -c &lt;message&gt;python3 decrypt.py -h for more information on the inputs.Flag format: dvCTF{[REDACTED]}Connection info: nc crypto.dvc.tf 2000 decrypt.py1234567891011121314151617181920212223242526272829303132from Crypto.Util.Padding import unpadfrom Crypto.Cipher import AESimport argparseimport hashlibdef decrypt_fct(private_key: int, iv: str, ciphertext: str) : derived_aes_key = hashlib.sha256(str(private_key).encode('ascii')).digest() cipher = AES.new(derived_aes_key, AES.MODE_CBC, bytes.fromhex(iv)) return unpad(cipher.decrypt(bytes.fromhex(ciphertext)),16,'pkcs7').decode() # unpad can be remove if you don't have the dependenciesdef main() : parser = argparse.ArgumentParser(description= &quot;returns decrypted message, AES CBC Mode encryption&quot;) parser.add_argument(&quot;-k&quot;, &quot;--key&quot;, type=str, help = &quot;The secret key used must be given in its integer form&quot;, required=True) parser.add_argument(&quot;-iv&quot;, &quot;--init_vector&quot;, type=str, help = &quot;iv must be given in its hex value&quot;, required=True) parser.add_argument(&quot;-c&quot;, &quot;--cipher&quot;, type=str, help = &quot;cipher must be given in its hex value&quot;, required= True) args = parser.parse_args() try : key = int(args.key) iv = args.init_vector cipher = args.cipher except : raise Exception(&quot;Error in the inputs, please try -h for more infos&quot;) try: message = decrypt_fct(key, iv, cipher) print(message) except: print(&quot;Please, check your inputs because decryption isn't possible.&quot;)if __name__ == '__main__': main() Check thử kết nối với server, ta thu được đoạn thông tin sau: 1234567891011121314151617181920212223242526272829303132333435# First connectionFrom Leonard:{'A': 28495810439427941743580652043307254742357428557373902639704121489048466785354237066969773928423017411801274631601564333367938091383442370280442923983663523206964188187977487944471477312407484259882669946821281142379664003865499339919542586375615288087871250173008915454256070825132728491120897580226872039819735498708106787459903970892884435364623918607275866286354216351978334720715506683283109326820482809493944496741992591729337918984878533478103, 'g': 2, 'p': 67909058639015901521159994775573035383954459487261606166344237532826148072679017733601374658223148561768415561603664175917512048376819174420250853454732953324581854497582753829708301928284664779076154088688830021115279512578857692227479562674882071152106576596875913352557789324670379649786609825434409435255821942736505342286648408198244821312692516037516042858869576975348446692782484818336732578529321186507590599512517447475812534029481702096279}From his friend:{'B': 5958777297152924037701869753380991463266385309786916650018293530882365971814121483536854848324475390900091298324661488252892967580225291270979534466996070980817914459680656396808275529132061312082468120893434430964919805935606562404775940844800572708717873092609026416279509731798475482209430075237376153530764430228864694515630814465606995124519286884593977342766610016458075057899234554667384037105157258488328071127322324048453301198646307937333, 'iv': '352f60625814348d3c74791f55491a01', 'message': '3550f92f89b4a981e4fb803c2e4195512a721cef7698a1d10da7afb8d5325226553b176a468f2fae2716ecb9cc02b810112064ea409aadb95c3848526746d3d1'}You can now speak with Leonard's friend: the accepted format is a dictionnary in json format: {&quot;A&quot;: &lt;integer&gt;, &quot;g&quot;: &lt;integer&gt;, &quot;p&quot;: &lt;integer&gt;}{&quot;A&quot;: 28495810439427941743580652043307254742357428557373902639704121489048466785354237066969773928423017411801274631601564333367938091383442370280442923983663523206964188187977487944471477312407484259882669946821281142379664003865499339919542586375615288087871250173008915454256070825132728491120897580226872039819735498708106787459903970892884435364623918607275866286354216351978334720715506683283109326820482809493944496741992591729337918984878533478103, &quot;g&quot;: 2, &quot;p&quot;: 55938199274440651808400169480277145310129203776384790123030426966266470781983277388615243836675492161588404195754822829434964198754883125404333712190912521088233281991969967904330602449829475994315793698600639312983932507743226893469758343815241554811298112532161401686144307632304633229321887364267590546755374100808072455065916443104238779625297200385725848287859722375292203647697013541803189116253024069989174714860163693232210878024031780891373}Received from his friend:{'B': 46220300434264812861438768027863424425103234948207240276710685798908763907865942524495490514495194806431790366288187212218271985917067514452414499454443119597756533934107608719546891047619822837648838472402279680608918309196713991187242724785785786115123996684936608984516266322647963102038073445852786897428852883328103558089075893335140324024615390186853105794444184349348949569542056127527373095371415479729996910985341371634846472649916257642396}# Second connectionFrom Leonard:{'A': 52428026319599185489635741560203305858485491199790610653957111011706389382868940621130747160711393007135731557349015022983393851106287127226431586686264577139296958680212594141845892105312277656430909577380050570920224174146168229047141796068473255274075749717954913415486871912565513186300935628194430042006973551101147532073079275285552486023753910626489511862686267100494063368708259733097656200052079583303871452672417541929834801232333230448435, 'g': 2, 'p': 67909058639015901521159994775573035383954459487261606166344237532826148072679017733601374658223148561768415561603664175917512048376819174420250853454732953324581854497582753829708301928284664779076154088688830021115279512578857692227479562674882071152106576596875913352557789324670379649786609825434409435255821942736505342286648408198244821312692516037516042858869576975348446692782484818336732578529321186507590599512517447475812534029481702096279}From his friend:{'B': 5958777297152924037701869753380991463266385309786916650018293530882365971814121483536854848324475390900091298324661488252892967580225291270979534466996070980817914459680656396808275529132061312082468120893434430964919805935606562404775940844800572708717873092609026416279509731798475482209430075237376153530764430228864694515630814465606995124519286884593977342766610016458075057899234554667384037105157258488328071127322324048453301198646307937333, 'iv': '51c795839e99e7b5b4f85e5e429fe4fd', 'message': '2342b518f7ef7ef73ce85c92e1d242c7ff3e0aff19e54b4de5632932c15063830f3147a006486d737149ac9bd9f56b63b14000747b2f435e940c70f3c9334eb3'}You can now speak with Leonard's friend: the accepted format is a dictionnary in json format: {&quot;A&quot;: &lt;integer&gt;, &quot;g&quot;: &lt;integer&gt;, &quot;p&quot;: &lt;integer&gt;}{&quot;A&quot;: 52428026319599185489635741560203305858485491199790610653957111011706389382868940621130747160711393007135731557349015022983393851106287127226431586686264577139296958680212594141845892105312277656430909577380050570920224174146168229047141796068473255274075749717954913415486871912565513186300935628194430042006973551101147532073079275285552486023753910626489511862686267100494063368708259733097656200052079583303871452672417541929834801232333230448435, &quot;g&quot;: 2, &quot;p&quot;: 67909058639015901521159994775573035383954459487261606166344237532826148072679017733601374658223148561768415561603664175917512048376819174420250853454732953324581854497582753829708301928284664779076154088688830021115279512578857692227479562674882071152106576596875913352557789324670379649786609825434409435255821942736505342286648408198244821312692516037516042858869576975348446692782484818336732578529321186507590599512517447475812534029481702096549}Received from his friend:{'B': 24232949087408601227993088107046604889023588772483337371158596374830398061136314870334085212681096751633551655012226041538173162269608480974541637107137623548917827986112594956218139496238240576386137123182279388825720678908979088327870636936163503406106334848025458155927428049099320243104440121811853057823375593714020877254975267418817139932607971909860849957970178836618173012567644006562215518742508540687598009638099544280541788742619996036520} Những yêu cầu đối với bộ {&quot;A&quot;: &lt;int&gt;, &quot;g&quot;: &lt;int&gt;, &quot;p&quot;: &lt;int&gt;} như sau: A là public key của Leonard, PK này trong lần đầu và lần thứ 2 nói chuyện phải giống nhau; g luôn nhận giá trị 2; p là 1 số nguyên tố, nhận giá trị không bé hơn A. Đến đây thì mình đã nghĩ đến sơ đồ truyền khóa DHKE, nhận thấy kết quả trả về lần nói chuyện thứ 2 khả năng cao là giá trị 2skb (mod pnew)2^{sk_{b}}\\,(\\text{mod } p_{new})2skb​(mod pnew​), trong đó pnewp_{new}pnew​ là số nguyên tố mà ta có thể chọn để có thể dễ dàng tính được skbsk_{b}skb​, ở đây ưu tiên số nguyên tố mà p−1p - 1p−1 phân tích được thành nhân tử là những số nguyên tố bé, sau đó sử dụng CRT để tìm skbsk_{b}skb​ ban đầu. Trong bài này mình đã chọn số nguyên tố sau: 12p = 55938199274440651808400169480277145310129203776384790123030426966266470781983277388615243836675492161588404195754822829434964198754883125404333712190912521088233281991969967904330602449829475994315793698600639312983932507743226893469758343815241554811298112532161401686144307632304633229321887364267590546755374100808072455065916443104238779625297200385725848287859722375292203647697013541803189116253024069989174714860163693232210878024031780891373 = 1 + 2^2 * 37 * 43 * 151 * 331 * 337 * 367 * 439 * 487 * 523 * 773 * 1019 * 1249 * 1559 * 2999 * 4567 * 4597 * 6841 * 7523 * 7877 * 9067 * 10093 * 10459 * 10567 * 10607 * 11059 * 11071 * 11311 * 12959 * 13033 * 14143 * 14479 * 14957 * 15467 * 16673 * 21059 * 23063 * 23879 * 24229 * 25111 * 25391 * 26723 * 26921 * 27059 * 28597 * 28703 * 29587 * 30817 * 32261 * 34127 * 35069 * 35677 * 35897 * 39631 * 39703 * 43391 * 44249 * 44701 * 49477 * 49939 * 54163 * 54601 * 55313 * 57059 * 58481 * 58537 * 60293 * 60449 * 60953 * 61463 * 61909 * 62873 * 64579 * 65587 * 65881 * 70199 * 72161 * 73757 * 73877 * 75013 * 75209 * 75707 * 75979 * 77621 * 79153 * 83719 * 86239 * 88493 * 90271 * 104033 * 107351 * 108631 * 111509 * 145799 * 164191 * 164231 * 166259 * 170239 * 176299 * 178753 * 183823 * 188417 * 200899 * 766531 Tìm B’s secret key qua giải CRT (phương pháp tìm Discrete Logarithm khi đã biết rõ factor của trong Theory number): 123456789101112131415161718p = 55938199274440651808400169480277145310129203776384790123030426966266470781983277388615243836675492161588404195754822829434964198754883125404333712190912521088233281991969967904330602449829475994315793698600639312983932507743226893469758343815241554811298112532161401686144307632304633229321887364267590546755374100808072455065916443104238779625297200385725848287859722375292203647697013541803189116253024069989174714860163693232210878024031780891373F = [2, 37, 43, 151, 331, 337, 367, 439, 487, 523, 773, 1019, 1249, 1559, 2999, 4567, 4597, 6841, 7523, 7877, 9067, 10093, 10459, 10567, 10607, 11059, 11071, 11311, 12959, 13033, 14143, 14479, 14957, 15467, 16673, 21059, 23063, 23879, 24229, 25111, 25391, 26723, 26921, 27059, 28597, 28703, 29587, 30817, 32261, 34127, 35069, 35677, 35897, 39631, 39703, 43391, 44249, 44701, 49477, 49939, 54163, 54601, 55313, 57059, 58481, 58537, 60293, 60449, 60953, 61463, 61909, 62873, 64579, 65587, 65881, 70199, 72161, 73757, 73877, 75013, 75209, 75707, 75979, 77621, 79153, 83719, 86239, 88493, 90271, 104033, 107351, 108631, 111509, 145799, 164191, 164231, 166259, 170239, 176299, 178753, 183823, 188417, 200899, 766531]g = 2B = 46220300434264812861438768027863424425103234948207240276710685798908763907865942524495490514495194806431790366288187212218271985917067514452414499454443119597756533934107608719546891047619822837648838472402279680608918309196713991187242724785785786115123996684936608984516266322647963102038073445852786897428852883328103558089075893335140324024615390186853105794444184349348949569542056127527373095371415479729996910985341371634846472649916257642396r = []for n in F: q = (p - 1) // n B1 = pow(B, q, p) g1 = pow(g, q, p) for i in range(n): if pow(g1, i, p) == B1: r.append(i) breakprint(&quot;r = &quot;, r) sagemath1234567F = [4, 37, 43, 151, 331, 337, 367, 439, 487, 523, 773, 1019, 1249, 1559, 2999, 4567, 4597, 6841, 7523, 7877, 9067, 10093, 10459, 10567, 10607, 11059, 11071, 11311, 12959, 13033, 14143, 14479, 14957, 15467, 16673, 21059, 23063, 23879, 24229, 25111, 25391, 26723, 26921, 27059, 28597, 28703, 29587, 30817, 32261, 34127, 35069, 35677, 35897, 39631, 39703, 43391, 44249, 44701, 49477, 49939, 54163, 54601, 55313, 57059, 58481, 58537, 60293, 60449, 60953, 61463, 61909, 62873, 64579, 65587, 65881, 70199, 72161, 73757, 73877, 75013, 75209, 75707, 75979, 77621, 79153, 83719, 86239, 88493, 90271, 104033, 107351, 108631, 111509, 145799, 164191, 164231, 166259, 170239, 176299, 178753, 183823, 188417, 200899, 766531]r = [1, 32, 10, 119, 164, 89, 91, 433, 137, 85, 63, 190, 779, 207, 2093, 748, 2412, 6520, 1580, 1606, 8288, 5002, 8768, 3876, 7635, 4201, 5108, 7928, 5784, 10692, 13308, 10449, 2913, 15147, 12642, 479, 10016, 14291, 19594, 8661, 19357, 24547, 26520, 6333, 2412, 13819, 12593, 1219, 30943, 17347, 14880, 5065, 30718, 34264, 28959, 26175, 36543, 4563, 900, 41850, 47097, 41697, 9499, 34293, 49142, 37764, 48600, 3120, 47070, 9274, 52064, 42558, 51797, 30467, 28304, 69570, 48900, 48283, 57321, 58258, 25109, 72146, 70627, 7754, 46847, 47820, 4597, 82377, 38675, 103918, 41510, 61978, 32580, 14256, 159132, 30688, 80680, 166901, 173775, 70604, 78878, 47379, 20095, 193903]b = crt(r, F)print(&quot;b = &quot;, b) # b = 9535440534258834121769569640499199561934282982790658252497837758809914458523729733418481304164992451274002723885772431265722323740597782168022676885255332109588519834413479447317457536202413819036024174400848981510769214886522790679151083510608905168377452971272621393851051993304455040449956990493245272199310314449211707436470794201546430018277011169649323905791913735882824727299802350608943156549141657833006376646183171395401386535369942013201# b = 65473639808699485930169739120776344872063486759175448375528264725076385240507007122033725140840484612862406919640595260700686522495480907572356389076167853197821801826383447351648059986031889813351817873001488294494701722629749684148909427325850459979675565503434023079995359625609088269771844354760835818954684415257284162502387237305785209643574211555375172193651636111175028374996815892412132272802165727822181091506346864627612264559401722904573 Mình vừa nhận ra mình đã bỏ quên 1 chi tiết quan trọng nữa, đó là số nguyên tố mình chọn nhỏ hơn ppp ban đầu, do đó skbsk_bskb​ có thể nhận 2 giá trị là skbsk_bskb​ và skb+pnewsk_b + p_{new}skb​+pnew​, và mình đã đúng. 1234567891011121314151617from Crypto.Util.Padding import unpadfrom Crypto.Cipher import AESimport argparseimport hashlibdef decrypt_fct(private_key: int, iv: str, ciphertext: str) : derived_aes_key = hashlib.sha256(str(private_key).encode('ascii')).digest() cipher = AES.new(derived_aes_key, AES.MODE_CBC, bytes.fromhex(iv)) return unpad(cipher.decrypt(bytes.fromhex(ciphertext)),16,'pkcs7').decode() # unpad can be remove if you don't have the dependencieskey = 33730236562858783079318804195298648719433949503171998744899006924279883641693998359987336249544481786268873611104231518373922791724577950286599631818965699426098433443505567998054674692816255431379437027966857897365726813356426107575974634463162905059625954223449434339174521876537018901019912447313534000308524739195811097809736962917373301383256547982444688204397607029340080842113725598762021026158263161844463037655676011936365809824949211118258iv = &quot;352f60625814348d3c74791f55491a01&quot;cipher = &quot;3550f92f89b4a981e4fb803c2e4195512a721cef7698a1d10da7afb8d5325226553b176a468f2fae2716ecb9cc02b810112064ea409aadb95c3848526746d3d1&quot;message = decrypt_fct(key, iv, cipher)print(message) 1dvCTF{0M6_1_5h0u1d_Ch4n63_M9_K39_F0r_34ch_3xch4n63!} Da Vinci’s Clock (medium, 500) Leonard and his friend are discussing but his friend can’t help but brag about the speed of his new computer.As part of an investigation, we managed to eavesdrop a part of their exchange and recovered a dump of his friend’s memory.The memory got a bit corrupted during the extraction but would you be able to recover the intercepted message ?Files: chall.py; intercepted_message; memory_dumpFlag format: dvCTF{FLAG} chall.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from Crypto.Cipher import AESfrom hashlib import sha256from Crypto.Util.number import getPrime, inversefrom Crypto.Util.Padding import pad, unpadimport randomfrom time import timeimport osfrom tonelli_shanks import tonelli_shanksfrom collections import namedtuplePoint = namedtuple(&quot;Point&quot;, &quot;x y&quot;)O = 'Origin'def point_inverse(P: tuple): if P == O: return P return Point(P.x, -P.y % p)def point_addition(P: tuple, Q: tuple): if P == O: return Q elif Q == O: return P elif Q == point_inverse(P): return O else: # approx. time around 30µs when entering else's segment if P == Q: aux = ((3*P.x**2 + a) * inverse(2*P.y, p))%p else: aux = ((Q.y - P.y) * inverse((Q.x - P.x), p))%p Rx = (aux**2 - P.x - Q.x) % p Ry = (aux*(P.x - Rx) - P.y) % p R = Point(Rx, Ry) return Rdef double_and_add(P: tuple, n: int): Q = P R = O while n &gt; 0: if n % 2 == 1: R = point_addition(R, Q) Q = point_addition(Q, Q) n = n // 2 return RFLAG = b&quot;[REDACTED]&quot; p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFa = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFCb = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604BG = Point(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551# Leonard's public keyleonard_public_key = 31663442885885219669071274428005652588471134165143253841118506078548146970109leonard_public_point = Point(leonard_public_key, tonelli_shanks((leonard_public_key**3 + a*leonard_public_key + b)%p,p)[0])# My private keymy_private_key = random.randint(2**(243),2**244-1)# My public key:my_public_key = double_and_add(G, my_private_key).xprint(my_public_key)# Our shared private key:begin = time()shared_secret_key = double_and_add(leonard_public_point, my_private_key).xfor k in range(999999) : # I want to be precise on the computing time, i've even gave you the time it takes to run the function above! double_and_add(leonard_public_point, my_private_key)computing_time = (time() - begin)print(&quot;You can be proud I can compute my message in less than {}microsec&quot;.format(computing_time))# Encryption of my messagederived_aes_key = sha256(str(shared_secret_key).encode('ascii')).digest()iv = os.urandom(16)cipher = AES.new(derived_aes_key, AES.MODE_CBC, iv)ciphertext = cipher.encrypt(pad(FLAG,16,'pkcs7'))print(iv.hex())print(ciphertext.hex()) intercepted_message123438483999891907407175443591517451416704302242042818884161505760394826326870371 # public_keyYou can be proud I can compute my message in less than 10743.747201579188microsec2db22c78c2ed85ca292cd68abe025abc # ivb4a5e98ab7e8f092dcacf1798bd6c95972c5a06b3a9caa537bcdf872f7da46ce # ciphertext memory_dump12345678910111213141516171819202122232425262728293031323334 . ! D p 6 7 l Q E J i h * ` 0000?111:1?1?0?00:10?10010:101011?1:011?1?10:10111111:1011??10:1?110001:10111101:1001101?:00?01111:0010?001:10000111:1?010110:10?001??:11111000:0010010?:??000?10:0101010?:1111?010:10001?01:0?0???1?:?0?1110?:100?0?10:100101?0:?11111?1:0111010?:0??10?10:01111100:??11?1?1:1?0?0111 d : 4 5 + V ; K Y P S y e % 5 Q M S c = ] E R{ &gt; ) G &quot; Bài này lại là bài trao đổi khóa trong Elliptic Curve (EC), việc đầu tiên chúng ta làm là check order của EC và của Point G. Tuy nhiên kết quả lại không khả quan cho lắm: Sagemath123456789101112a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFCb = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604Bp = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFF = GF(p)E = EllipticCurve(F, [a, b])# ordE = E.order() # 115792089210356248762697446949407573529996955224135760342422259061068512044369 -- prime# print(ordE) G = E(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)ordG = G.order() # 115792089210356248762697446949407573529996955224135760342422259061068512044369 = ordEprint(ordG) Kết quả cho chúng ta chính bằng nnn và là 1 số nguyên tố lớn, do đó ta không thể áp dụng Smart’s Attack hay Pohlig-Hellman ‘s Attack trong case này được. Tuy nhiên trong memory dump chúng ta nhận thấy có 1 đoạn bit dài 48-bit, suy nghĩ ban đầu cho chúng ta thấy đây chính là my_private_key trong vùng nhớ. Ta cần private key dài 44-bit, nhưng ở trong chuỗi này có 48-bit bị hỏng, ý tưởng ban đầu của mình đơn giản thôi: vì đoạn 44-bit này bit đầu tiên có nghĩa, nên chúng ta cho bit đầu tiên giá trị 1, còn lại 47 bit thì ta brute :D Tuy nhiên thời gian cần thiết để tính là quá dài, do đó mình chưa giải được bài này. Update: Mình vừa nhận ra mình đã bỏ lỡ một chi tiết quan trọng, đó là thời gian. Chúng ta có dữ kiện rằng # approx. time around 30µs when entering else's segment, trong file thông tin bắt được, ta thấy mỗi lần tính shared secret key cần 10743.747201579188microse, chia cho 30 thu được 358.1249067193063 vòng: 244 vòng chạy mã hóa (vì sk dài 244 bit), 114 vòng cộng (bit 1) và thời gian xuất rất nhỏ. Trong đoạn bit vừa bắt được có 111 bit , do đó việc chúng ta cần làm là điền 3 bit vào trong chỗ còn thiếu -&gt; thời tới. 123456789101112131415pk = 38483999891907407175443591517451416704302242042818884161505760394826326870371unknow_idx = [238, 236, 234, 229, 217, 212, 210, 195, 194, 190, 168, 165, 155, 142, 133, 129, 128, 112, 111, 110, 106, 96, 91, 82, 78, 76, 75, 74, 72, 71, 69, 64, 60, 58, 49, 47, 41, 32, 30, 29, 26, 15, 14, 11, 9, 6, 4]sk = int(&quot;00001111101000001001001010101101011010101011111110110010101100011011110110011010000011110010000110000111100101101000010011111000001001000000001001010100111100101000100100000010000111001000001010010100011111010111010000010010011111000011010110000111&quot;,2)for i in range(0, len(unknow_idx)-2): for j in range(i + 1, len(unknow_idx)-1): for k in range(j + 1, len(unknow_idx)): s = sk t = (1 &lt;&lt; unknow_idx[i]) ^ (1 &lt;&lt; unknow_idx[j]) ^ (1 &lt;&lt; unknow_idx[k]) l = s ^ t if double_and_add(G, l).x == pk: print(&quot;l = &quot;, l) exit(0) Ta lúc này đã tìm được sk, và việc gì tới cũng phải tới :D Sagemath1234Leo_pk_x = 31663442885885219669071274428005652588471134165143253841118506078548146970109Leo_pk_x = E.lift_x(Leo_pk_x)print(Leo_pk_x) 12345678910111213sk = 27610939802316035421304285370883343604756496045638121948548836716464321927leonard_pk_x = 31663442885885219669071274428005652588471134165143253841118506078548146970109leonard_pk_y = 76156276912437516602584683740575357964060179918140758336762510346991347147838leonard_public_point = Point(leonard_pk_x, leonard_pk_y)shared_secret_key = double_and_add(leonard_public_point, sk).xderived_aes_key = sha256(str(shared_secret_key).encode('ascii')).digest()iv = bytes.fromhex(&quot;2db22c78c2ed85ca292cd68abe025abc&quot;)ct = bytes.fromhex(&quot;b4a5e98ab7e8f092dcacf1798bd6c95972c5a06b3a9caa537bcdf872f7da46ce&quot;)cipher = AES.new(derived_aes_key, AES.MODE_CBC, iv)pt = cipher.decrypt(ct)print(pt) 1dvCTF{7h3_Cl0ck_1s_71ck1n9!}","link":"/2023/davinci-ctf-2023/"},{"title":"Kalmar CTF 2023 Write-ups","text":"Mình vừa tham gia giải KalmarCTF 2023, mình giải được 4 bài, trong đó mảng Crypto làm được 2 bài dễ nhất liên quan đến One Time Pad :)) Bài Crypto thứ 3 mình có đọc và nghĩ hướng giải là …, nhưng mình vẫn chưa tìm ra cách nào để giảm thời gian làm bài xuống. Vì thời điểm mình viết write-up sau thời gian kết thúc làm bài nên không lấy được đề một số bài, mình sẽ update trong thời gian tới. MiscSanity Check (100) Have you read the rules? Chỉ đơn giản là đọc rules và lấy flag. 1kalmar{i_have_read_the_rules_and_each_player_has_their_own_account} Forensicsewing-waste-and-agriculture-leftovers (100)Đối với bài mình sử dụng công cụ wireshark, vào Analyze &gt;&gt; Follow &gt;&gt; UDP Stream ta thấy có thể ghép chữ cái từ những stream khác nhau lại để tạo thành flag có nghĩa. 12345678910111213141516..l..r{....t..i........d0.._.....e..m...e...u.......g......a..a.{.._4..........._d0.._..c.......y.e..ou.._.s........k..m....f_....ir........0.............y.......e..s1.......k..m.......t......_..u..0.........d.m.......ur................m.r....4....r...yo..d0.....c..e...a............1...u.........r..._...fi..._....d..._.ucc........e..ou......n...dp}....a.....4._.i.s._..u...nt_.....e........y...........ud...k..m....._.......t...u.......ucc....m................_.......l...{....t..i.s..y.u...n._..........y.......e........d.....ma......._....t..........s...e.......e.............u..}.k.l.a.{i...._....t.....d..._.................r...............l............r......_d.n..s..............o..........u.p.....m.......t.f............t.............e....r..us.............a........fir.t..o..d....s.cc....m.yb..y.........g..d....alma.....4...i........d.n........._..........._...n.........l.a...._4.........o..d0.t..u......ma.b._.........n.....}. 1kalmar{if_4t_first_you_d0nt_succeed_maybe_youre_us1ng_udp} CryptoBabyOneTimePad (100) I read about how encryption with one-time pads is unbreakable, so no one will be able to solve this challenge.nc 3.120.132.103 13338 challenge.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python3# &quot;BabyOneTimePad&quot; challenge for KalmarCTF 2023# based on &quot;EasyOneTimePad&quot;# original challenge by shalaamum# idea to make this easier variant by killerdogimport osPASS_LENGTH_BYTES = 128def encrypt_otp(cleartext, key = os.urandom(PASS_LENGTH_BYTES)): ciphertext = bytes([key[i % len(key)] ^ x for i,x in enumerate(cleartext.hex().encode())]) return ciphertext, keyif __name__ == '__main__': print('According to Wikipedia:') print('&quot;In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.&quot;') print('So have fun trying to figure out my password!') password = os.urandom(PASS_LENGTH_BYTES) enc, _ = encrypt_otp(password) print(f'Here is my password encrypted with a one-time pad: {enc.hex()}') print('Actually, I will give you my password encrypted another time.') print('This time you are allowed to permute the password first') permutation = input('Permutation: ') try: permutation = [int(x) for x in permutation.strip().split(',')] assert set(permutation) == set(range(PASS_LENGTH_BYTES)) enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)])) print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}') except: print('Something went wrong!') exit(1) password_guess = input('What is my password: ') try: password_guess = bytes.fromhex(password_guess) except: print('Something went wrong!') exit(1) if password_guess == password: with open('flag.txt', 'r') as f: flag = f.read() print(f'The flag is {flag}') else: print('Nope.') Mặc dù bài đầu tiên có nhiều sơ hở hơn so với bài thứ 2 (2 lần mã hóa đều sử dụng chung 1 pad key, không giới hạn độ dài permutation) nhưng mình vẫn không nghĩ ra :)) và vậy là mình giải quyết bài sau trước, sau đó giải quyết bài đầu, hơi ngược tí mà kệ :)) Trong bài này, server sẽ generate 1 string secret, nhiệm vụ của chúng ta là đoán ra secret và server sẽ cho chúng ta biết flag. Cùng xem chúng ta có dữ kiện gì: Chúng ta được biết giá trị đã pad của secret; Chúng ta được chọn 1 permutation bất kỳ để thay đổi secret, biết được giá trị đã pad của secret sau khi thay đổi; 2 lần pad trên sử dụng 2 key pad khác nhau; Độ dài của pad key là 128-bit, của secret là 256-bit, do đó pad key được sử dụng lặp lại 1 lần; Gọi nửa đầu của secret là , nửa sau là . Dựa vào dữ kiện (), ý tưởng làm bài như sau: Lấy giá trị đã XOR với key1 của secret P0⊕key1∥P1⊕key1P_{0}\\oplus key_{1}\\parallel P_{1}\\oplus key_{1}P0​⊕key1​∥P1​⊕key1​. Tính được h12=P0⊕P1h_{12}=P_{0}\\oplus P_{1}h12​=P0​⊕P1​; Chọn permutation dịch 1 bytes ở nửa đầu secret, giữ nguyên nửa sau của secret: (1,2,…,63,0,64,65,…,127)∈S128\\left(1,2,\\ldots,63,0,64,65,\\ldots,127\\right)\\in S_{128}(1,2,…,63,0,64,65,…,127)∈S128​; Lấy giá trị đã XOR với key2 của secret sau khi biến đổi (P0≫1)⊕key2∥P1⊕key2\\left(P_{0}\\gg1\\right)\\oplus key_{2}\\parallel P_{1}\\oplus key_{2}(P0​≫1)⊕key2​∥P1​⊕key2​. Tính được h34=(P0≫1)⊕P1h_{34}=\\left(P_{0}\\gg1\\right)\\oplus P_{1}h34​=(P0​≫1)⊕P1​, trong đó P0≫1P_{0}\\gg1P0​≫1 là kết quả shift 1 byte của P0P_{0}P0​ về bên phải; Tính giá trị h1234=(P0≫1)⊕P0h_{1234}=\\left(P_{0}\\gg1\\right)\\oplus P_{0}h1234​=(P0​≫1)⊕P0​. Từ đây, chúng ta đoán bytes đầu tiên của P0P_0P0​ sao cho tất cả các bytes còn lại đều hợp lệ; Tìm được bytes đầu tiên của P0P_0P0​ và giá trị đúng của P0P_0P0​, tính giá trị P1=h12⊕P0P_1 = h_{12} \\oplus P_0P1​=h12​⊕P0​; Ghép secret=P0∥P1secret = P_0 \\parallel P_1secret=P0​∥P1​ và submit đáp án. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *r = remote(&quot;3.120.132.103&quot;, 13338)enc1 = bytes.fromhex(r.recvline_startswith(b'Here is my password encrypted with a one-time pad:').decode().strip('\\n')[51:])assert len(enc1) == 256h1 = list(enc1[:128])h2 = list(enc1[128:])h12 = [h1[i] ^ h2[i] for i in range(128)]print(&quot;h12 = &quot;, h12) # --&gt; Kết quả XOR nửa đầu P0 và nửa sau P1 của secret# Chọn permutation như sau:# [1, 2, ..., 63, 0, 64, 65, ..., 127]# Secret lúc này có dạng nửa đầu P0(&gt;&gt;1) và nửa sau P1permutation = &quot;&quot;# for _ in range(128):# permutation += &quot;127,&quot;for i in range(64): permutation += str((i-1)%64) + &quot;,&quot;for i in range(64, 128): permutation += str(i) + &quot;,&quot; permutation = permutation[:-1]# print(permutation)p = [int(x) for x in permutation.strip().split(',')]print(&quot;p = &quot;,p)r.sendlineafter(b'Permutation: ', permutation.encode())enc2 = bytes.fromhex(r.recvline_startswith(b'Here is the permuted password encrypted with another one-time pad:').decode().strip('\\n')[67:])assert len(enc2) == 256h3 = list(enc2[:128])h4 = list(enc2[128:])# print(&quot;h3 = &quot;, h3)# print(&quot;h4 = &quot;, h4)h34 = [h3[i] ^ h4[i] for i in range(128)]print(&quot;h34 = &quot;, h34) # --&gt; Kết quả XOR nửa đầu P0(&gt;&gt;1) và nửa sau P1 của secreth1234 = [h12[i] ^ h34[i] for i in range(128)]print(&quot;h1234 = &quot;, h1234) # --&gt; Kết quả XOR nửa đầu P0(&gt;&gt;1) và nửa đầu P0 của secret# đoán byte đầu tiên của P0guest = &quot;0123456789abcdef&quot;passwd1 = []for c in guest: passwd1.clear() passwd1.append(c) for j in range(0,128, 2): ch = chr(ord(passwd1[j // 2]) ^ h1234[(2 + j) % 128]) if ch in guest: passwd1.append(ch) else: break if (len(passwd1) == 65): breakprint(passwd1)passwd2 = []for c in guest: passwd2.clear() passwd2.append(c) for j in range(1,128, 2): ch = chr(ord(passwd2[j // 2]) ^ h1234[(2 + j) % 128]) if ch in guest: passwd2.append(ch) else: break if (len(passwd2) == 65): breakprint(passwd2)password_h1 = []for i in range(128): if i%2 == 0: password_h1.append(passwd1[i//2]) else: password_h1.append(passwd2[i//2])print(password_h1) # --&gt; tính được nửa đầu P0, việc còn lại là tính nửa sau P1 dựa vào XOR h12for i in range(128): password_h1.append(chr(ord(password_h1[i]) ^ h12[i]))print(str(password_h1))# --&gt; Ghép P0 và P1 lại với nhau và submit đáp ánpassword = &quot;&quot;for i in range(len(password_h1)): password += password_h1[i]r.sendlineafter(&quot;What is my password: &quot;, password.encode())flag = r.recvline().decode().strip('\\n')print(flag) 1kalmar{why_do_default_args_work_like_that_0.0} EasyOneTimePad (100) I fixed the mistake from last time, now it should be secure - right?nc nc 3.120.132.103 13341 Do bài phía mình đã giải quyết được bài toán tổng quát hơn, nên đối với bài toán nhỏ hơn này thì mình chỉ việc sử dụng lại code và lấy flag :)) 1kalmar{guess_i_should_have_read_the_whole_article} Bài sau đây là bài mà mình vẫn chưa giải được, đợi write-up từ các Pro vậy :( DreamHash I fell asleep in my abstract algebra class and dreamt of this weird hash function, so I decided to make a challenge with it. Can you solve it?nc {Remote server IP and PORT} challenge.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env python3# &quot;DreamHash&quot; challenge for KalmarCTF 2023# by shalaamumimport randomimport base64VALUESIZE = 216BLOCKSIZE = 16class Value: def __init__(self, n): if isinstance(n, Value): n = n.n if not (isinstance(n, int) and 0 &lt;= n &lt;= VALUESIZE): raise ValueError self.n = n def __eq__(self, other): return self.n == other.n def extract(self): a = self.n % 3 b = ((self.n // 27) + 1) % 3 c = (self.n // 9) % 3 d = (((self.n // 27) + 1) // 3) % 3 if b == 0: f = (self.n // 3) % 3 e = (2 * d) % 3 else: e = (self.n // 3) % 3 f = ((1 + d*e) * b) % 3 return a,b,c,d,e,f @classmethod def assemble(cls, a, b, c, d, e, f): for x in (a,b,c,d,e,f): if not (isinstance(x, int) and 0 &lt;= x &lt;= 2): raise ValueError n = 0 n += a n += 27 * ((b + 3 * d) - 1) n += 9 * c if b == 0: n += 3 * f else: n += 3 * e return Value(n) def __add__(self, other): sa, sb, sc, sd, se, sf = self.extract() oa, ob, oc, od, oe, of = other.extract() a = (sa + sb * oa + sd * oc) % 3 b = (sb * ob + sd * oe) % 3 c = (sc + se * oa + sf * oc) % 3 d = (sb * od + sd * of) % 3 e = (se * ob + sf * oe) % 3 f = (se * od + sf * of) % 3 return Value.assemble(a, b, c, d, e, f) def __str__(self): return str(self.n) def __repr__(self): return repr(self.n)class DreamHash: def __init__(self): # I read that it is important to use nothing-up-my-sleeves-numbers for # constants in cryptosystems, so I generate the template randomly. self.template = [ random.sample( sum([[(i+j) % BLOCKSIZE]*(1 if j == 0 else j*VALUESIZE) for j in range(BLOCKSIZE)], []), k=(1 + VALUESIZE * sum(range(BLOCKSIZE))) ) for i in range(BLOCKSIZE) ] def hash(self, data): unfolded_data = [Value(d) for d in data] unfolded_data += [Value(0)] * (BLOCKSIZE - (len(unfolded_data) % BLOCKSIZE)) folded_data = [sum(unfolded_data[i::BLOCKSIZE], Value(0)) for i in range(BLOCKSIZE)] result = [] for i in range(BLOCKSIZE): result.append(Value(0)) for j in self.template[i]: result[-1] += folded_data[j] return [x.n for x in result]def main(): print('Welcome to the DreamHash testing service.') H = DreamHash() secret = bytes([random.randrange(VALUESIZE) for _ in range(BLOCKSIZE)]) print('I generated a secret. Can you recover it?') for _ in range(4): try: user_bytes = base64.b64decode(input('Your values: ')) h = H.hash(secret + user_bytes) print(f'Hash: {base64.b64encode(bytes(h)).decode()}') except: exit(0) user_bytes = base64.b64decode(input('Your guess at secret: ')) if user_bytes == secret: with open('flag.txt', 'r') as f: print(f.read()) else: print('Wrong.\\n')if __name__ == '__main__': main() Reconstruction (842) Shamir agreed to keep my flag secret for me in his stronghold. He assured me that the adversary would never cross its threshold. But the adversary commanded vast legions, and broke through to the threshold. There remains only one defense against reconstruction.Note: This challenge requires some extended computation. Our (very unoptimised) solve script terminates in under 30 minutes :) chal.sage1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import randomrng = random.SystemRandom()num_parties = 1000threshold = int(0.1111 * num_parties)num_compromised = int(0.37 * num_parties)prime = (2**384).next_prime()F = GF(prime)class Party: def __init__(self, share): self.share = share self.compromised = False def compromise(self): self.compromised = True def get_share(self): if self.compromised: return self.share else: return F(rng.randrange(F.order()))def share(secret): R.&lt;x&gt; = F['x'] poly = secret * x**threshold for i in range(threshold): poly += x**i * F(rng.randrange(F.order())) return [Party(poly(F(j))) for j in range(num_parties)]def main(): with open('flag.txt', 'r') as f: flag = f.read().strip() assert(len(flag) &lt; prime.nbits()*8) # Share the secret. secret = F(int.from_bytes(flag.encode(), 'little')) parties = share(secret) # Oops, the adversary has compromised some of the parties! for i in rng.sample(range(num_parties), num_compromised): parties[i].compromise() # The adversary is requesting the shares! All is lost! for s in parties: print(s.get_share())if __name__ == &quot;__main__&quot;: main() Tổng hợp những gì chúng ta đã biết: Số nguyên tố prime chọn là 385-bit, khả năng flag dài 48 ký tự; Generated 1 đa thức poly∈GF(p)[x]poly\\in GF(p)[x]poly∈GF(p)[x] bậc 111, trong đó: Hệ số của x111x^{111}x111 là giá trị của flag chuyển sang int; 111 hệ số còn lại của x0,…,x110x^{0}, \\ldots, x^{110}x0,…,x110 là những số ngẫu nhiên dài 384-bit; Trong 1000 dòng giá trị trong file output.txt: 370 dòng là giá trị của đa thức poly tại giá trị j, tương ứng với index của dòng; 630 dòng còn lại là những giá trị ngẫu nhiên; Ý tưởng làm bài này của mình như sau: Chọn 112 cặp giá trị khả năng (ai,bi)=(j,f(j)); i∈0,112‾, j∈0,999‾(a_{i},b_{i})=(j,f(j));\\;i\\in\\overline{0,112},\\,j\\in\\overline{0,999}(ai​,bi​)=(j,f(j));i∈0,112​,j∈0,999​. Sử dụng công thức đa nội suy Lagrange để tìm polynomial f∈GF(p)[x]f\\in GF(p)[x]f∈GF(p)[x] thỏa mãn điều kiện f(ai)=bi ∀ i∈0,112‾ f(a_{i})=b_{i}\\;\\forall\\,i\\in\\overline{0,112}f(ai​)=bi​∀i∈0,112​ Kiểm tra polynomial thu được bậc bằng 111 hay không? Nếu có, kiểm tra xem hệ số x111x^{111}x111 có phải là biểu diễn của flag hay không? Nếu có, đưa kết quả ra màn hình và kết thúc chương trình, nếu không thì quay lại bước 1. Xác suất của cách làm này bằng (370112)(1000112)=370!112!258!1000!112!888!=888!×370!1000!×258!=259×…×370889×…×1000&lt;(0,37)112≈0 \\frac{\\binom{370}{112}}{\\binom{1000}{112}}=\\frac{\\frac{370!}{112!258!}}{\\frac{1000!}{112!888!}}=\\frac{888!\\times370!}{1000!\\times258!}=\\frac{259\\times\\ldots\\times370}{889\\times\\ldots\\times1000}&lt;\\left(0,37\\right)^{112}\\approx0(1121000​)(112370​)​=112!888!1000!​112!258!370!​​=1000!×258!888!×370!​=889×…×1000259×…×370​&lt;(0,37)112≈0 rất nhỏ :(( Tuy nhiên mình vẫn chưa nghĩ ra phương án loại đi những số ngẫu nhiên. Đợi có write-up tham khảo sau vậy.","link":"/2023/kalmar-ctf-2023-write-ups/"},{"title":"LA CTF 2023 Write-ups","text":"Lần đầu tự viết write-up :)) Cuộc thi này mình mới chỉ biết đến hôm nay (23/2) nên không tham gia kịp, chỉ là xem challenges và viết bài giải của mình thôi. Đánh giá của mình thì bài ở đây khá hay, đa số thời gian yêu cầu để giải hợp lý và không yêu cầu quá nhiều về các bước xử lý. One more time pad I heard the onetime pad is perfectly secure so I used it to send an important message to a friend, but now a UCLA competition is asking for the key? I threw that out a long time ago! Can you help me recover it? chall.py Bài này chỉ đơn giản là One-time-pad được sử dụng lặp đi lặp lại, việc của mình chỉ là XOR từng ký tự của plaintext với ciphertext để tìm ra key ban đầu. text.py1234567891011pt = b&quot;Long ago, the four nations lived together in harmony ...&quot;ct = &quot;200e0d13461a055b4e592b0054543902462d1000042b045f1c407f18581b56194c150c13030f0a5110593606111c3e1f5e305e174571431e&quot;key = &quot;&quot;for i in range(len(pt)): ch = int(ct[i*2:i*2+2], 16) k = pt[i] ^ ch key += chr(k) if chr(k) == '}': breakprint(&quot;Flag =&quot;, key) 1Flag = lactf{b4by_h1t_m3_0ne_m0r3_t1m3} Rolling in the mud uugh, these pigs in my pen are making a complete mess! They’re rolling all over the place!Anyway, can you decode this cipher they gave me, almost throwing it at me while rolling around?Answer in lowercase with symbols. In the image, { and } are characters that should appear in your flag, and replace spaces with _. Có thể nhìn ra ngay 5 chữ đầu tiên của Flag là lactf, chúng ta có thể suy đoán rằng ở đây sử dụng mật mã dạng lồng. Thật vậy, bảng mã hóa của bài này như sau: 1lactf{rolling_and_rolling_and_rolling_until_the_pigs_go_home}. P/s: Sau một hồi tìm hiểu thì mã này có tên là Pigpen cipher. Chinese lazy theorem 1 I heard about this cool theorem called the Chinese Remainder Theorem, but, uh… I’m feeling kinda tired right now. nc lac.tf 31110 chinese-lazy-theorem-1.py Bài này ý tưởng chỉ đơn giản là tính số n=p∗qn = p * qn=p∗q, vì target cần đoán bé hơn n−1n - 1n−1 nên target % (n−1)=targettarget \\, \\% \\, (n - 1) = targettarget%(n−1)=target. 12345678910111213141516from pwn import *r = remote(&quot;lac.tf&quot;, 31110)p = int(r.recvline().decode(), 10)q = int(r.recvline().decode(), 10)n = p*qr.sendlineafter(&quot;&gt;&gt; &quot;, b'1')r.sendlineafter(&quot;Type your modulus here: &quot;, str(n - 1).encode())trg = r.recvline().decode()r.sendlineafter(&quot;&gt;&gt; &quot;, b'2')r.sendlineafter(&quot;Type your guess here: &quot;, trg)flag = r.recvline().decode('utf-8').strip('\\n')print(&quot;Flag = &quot;, flag) 1Flag = lactf{too_lazy_to_bound_the_modulus} Greek cipher You think you’ve seen all of the “classic” ciphers? Instead of your standard cipher, I’ve created my own cipher: the monoalphagreek cipher!Answer with just the flag in lowercase with symbols left in. greek.txt Nhìn vào οσμιδ{...} có độ dài tương ứng với lactf{...}, do đó ta có suy đoán ban đầu đây là substitution cipher. Việc còn lại chỉ là tìm sự tương ứng giữa các từ để tìm ra bảng mã. plaintext123did you know that julius caesar was not the first person in history suspected of using encryption? me neither.did you know that julius caesar was probably fluent in greek? me neither.i like how greek character look though, even if i can't read them. 1lactf{i_guess_using_many_greek_characters_didn't_stop_you._well_played_i_must_say.congrats!} Guess the bit! I’m trying out for this new game show, but it doesn’t seem that hard since there are only two choices? Regardless, I heard someone name Pollard could help me out with it? nc lac.tf 31190 chall.py Ý tưởng cho bài này khá đơn giản, giả sử c=6k.t, 6∤ tc = 6^k \\ldotp t,\\; 6 \\not | \\;tc=6k.t,6∣t, thì c2=62k.t2, 6∤ tc^2 = 6^{2k} \\ldotp t^2,\\; 6 \\not | \\;tc2=62k.t2,6∣t. Việc cần làm hiện tại là kiểm tra số mũ của 6 trong kết quả phân tích c2c^{2}c2. Nếu mũ chẵn thì b=0b = 0b=0 và ngược lại. 123456789101112131415161718192021222324from pwn import *from tqdm import tqdmr = remote(&quot;lac.tf&quot;, 31190)n = int(r.recvline()[4:].decode(), 10)a = int(r.recvline()[4:].decode(), 10)for _ in tqdm(range(150)): c = int(r.recvline()[4:].decode(), 10) k = 0 while (c % 6 == 0): k += 1 c = c // 6 if k % 2 == 0: choice = b'0' else: choice = b'1' r.sendlineafter(&quot;What is your guess? &quot;, choice) # print(&quot;choice = &quot;, choice,&quot; --&gt; PASS&quot;)r.recvline()flag = r.recvline().decode('utf-8').strip('\\n')print(&quot;Flag = &quot;, flag) 1Flag = lactf{sm4ll_pla1nt3xt_sp4ac3s_ar3n't_al4ways_e4sy} Chinese lazy theorem 2 Ok I’m a little less lazy now but you’re still not getting much from me. nc lac.tf 31111 chinese-lazy-theorem-2.py Hmm lúc này thì challenger đã giới hạn modulus không vượt quá giá trị max(p,q)max(p, q)max(p,q), đồng thời không gian giá trị của target đã tăng lên n=2.3.5.p.qn = 2.3.5.p.qn=2.3.5.p.q, độ dài tối đa của target là 1030 bit. Do đó ý tưởng của bài này là chọn 2 số nguyên tố dài 512 bit bé hơn max(p,q)max(p, q)max(p,q): {target≡r1(mod p1)target≡r2(mod p2)⇒ target≡r (mod p1.p2) \\begin{cases} target\\equiv r_{1} &amp; (\\text{mod }p_{1}) \\\\ target\\equiv r_{2} &amp; (\\text{mod }p_{2}) \\end{cases}\\quad\\Rightarrow \\; target\\equiv r\\;(\\text{mod }p_{1}\\ldotp p_{2}) {target≡r1​target≡r2​​(mod p1​)(mod p2​)​⇒target≡r(mod p1​.p2​) Sử dụng tối đa 30 lần thử, chúng ta hoàn toàn có thể đó được 1030-bit target bằng cách gửi lên server số target+k.p1.p2, k∈1,30target + k.p_{1}.p_{2}, \\; k \\in {1, 30}target+k.p1​.p2​,k∈1,30 cho đến khi tìm ra được đáp án. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *from Crypto.Util.number import getPrimedef extended_euclid(a, b): if b == 0: return (1, 0) (x, y) = extended_euclid(b, a % b) k = a // b return (y, x - k * y)def invert_modulo(a: int, n: int) -&gt; int: (b, x) = extended_euclid(a, n) if b &lt; 0: b = (b % n + n) % n return br = remote(&quot;lac.tf&quot;, 31111)p = int(r.recvline().decode(), 10)q = int(r.recvline().decode(), 10)prime_nums = []while len(prime_nums) &lt; 2: prime = getPrime(512) if prime not in prime_nums: if prime &lt; p or prime &lt; q: prime_nums.append(prime)r.sendlineafter(&quot;&gt;&gt; &quot;, b'1')r.sendlineafter(&quot;Type your modulus here: &quot;, str(prime_nums[0]).encode())r0 = int(r.recvline().decode(), 10)r.sendlineafter(&quot;&gt;&gt; &quot;, b'1')r.sendlineafter(&quot;Type your modulus here: &quot;, str(prime_nums[1]).encode())r1 = int(r.recvline().decode(), 10)r_p1 = invert_modulo(prime_nums[0], prime_nums[1])trg = r0 + prime_nums[0] * ((r_p1 * (r1 - r0)) % prime_nums[1])n0 = prime_nums[0] * prime_nums[1]assert (trg &lt;= n0)assert (trg % prime_nums[0] == r0)assert (trg % prime_nums[1] == r1)r.sendlineafter(&quot;&gt;&gt; &quot;, b'2')for i in range(1, 31): r.sendlineafter(&quot;Type your guess here: &quot;, str(trg + n0 * i).encode()) print(&quot;try = &quot;, str(trg + n0 * i).encode()) msg = r.recvline().decode() if &quot;nope&quot; in msg: print(msg) continue else: print(&quot;Flag = &quot;, msg) break 1Flag = lactf{n0t_$o_l@a@AzY_aNYm0Re} Ravin cryptosystem I don’t really understand why people choose big numbers that can’t be factored. No one has been able to crack my RSA implementation even though my modulus is factorable. It should just be normal RSA??? All I did was make it faster. I’ve asked my friends and the only feedback I’ve gotten so far are rave reviews about how secure my algorithm is. Hmm, maybe I’ll name it the Ravin Cryptosystem. There better not be anyone with a similar idea. output.txt ravin.py Sử dụng trang factordb, ta nhanh chóng thu được phân tích của n=p.qn = p . qn=p.q. Tuy nhiên ở đây hàm fastpow đã được implement sai cách, dẫn đến việc tìm msg không giống với giải mã RSA thông thường: 123456789def fastpow(b, p, mod): # idk this is like repeated squaring or something i heard it makes pow faster a = 1 while p: p &gt;&gt;= 1 b = (b*b)%mod if p&amp;1: a = (a*b)%mod return a Lúc này flag m đã được mã hóa c=me−1(mod n)c = m^{e - 1} (\\text{mod } n)c=me−1(mod n). Vì GCD(e−1,φ(n))=4GCD(e-1, \\varphi(n) ) = 4GCD(e−1,φ(n))=4, chúng ta sẽ sử dụng extended_euclid để tìm u ⁣: cu=m4 (mod n)\\colon\\; c^u = m^4\\; (\\text{mod } n):cu=m4(mod n), sau đó tìm cu mod qc^{u} \\text{ mod } qcu mod q và cu mod pc^{u} \\text{ mod } pcu mod p. 1234567891011121314151617181920212223def extended_euclid(a, b): if b == 0: return (1, 0) (x, y) = extended_euclid(b, a % b) k = a // b return (y, x - k * y)n = 996905207436360486995498787817606430974884117659908727125853e = 65537c = 375444934674551374382922129125976726571564022585495344128269# p and q from factordbp = 861346721469213227608792923571q = 1157379696919172022755244871343assert(p*q == n)phi_n = (p-1)*(q-1)(u,v) = extended_euclid(e - 1, phi_n)assert(((e - 1) * u) % phi_n == 4)c_u = pow(c, u, n)c1 = c_u % pc2 = c_u % q Để tiện ký hiệu, đặt p1=p, p2=qp_1 = p,\\;p_2 = qp1​=p,p2​=q. Do 4∤pi−14 \\not | p_i-14∣pi​−1, trong field Zpi\\mathbb{Z}_{p_i}Zpi​​ chúng ta có thể tìm được 2 giá trị cij=m (mod pi)c_{ij} = m \\,(\\text{mod } p_i)cij​=m(mod pi​), sau đó sử dụng CRT để tìm m∈Znm \\in \\mathbb{Z}_{n}m∈Zn​. Trong bước này mình đã sử dụng wolframalpha để hỗ trợ tính toán. 1m = 40549930713646101196507797105878967309586158452159869 1Flag = lactf{g@rbl3d_r6v1ng5} Hill easy I found a cool rock. Help me figure out what it says. nc lac.tf 31140 chall.py Chúng ta sẽ sử dụng 10 lần thử đầu tiên để tìm ra ma trận A∈(Z95)N,N∗A \\in \\left(\\mathbb{Z}_{95}\\right)^{*}_{N,N}A∈(Z95​)N,N∗​: ban đầu chúng ta sẽ gửi đến server 10 string si, i∈0,9‾s_i, \\; i\\in \\overline{0,9}si​,i∈0,9​ dài 40 bytes, trong đó 2 ký tự thứ 2i2i2i và 2i+12i + 12i+1 của string sis_isi​ nhận giá trị chr(33)chr(33)chr(33), các ký tự còn lại nhận giá trị chr(32)chr(32)chr(32). stov(si[:n])=0…01i-th idx0…0 stov(s_i [:n]) = 0\\ldots 0\\underset{\\text{i-th idx}}{1} 0 \\ldots 0stov(si​[:n])=0…0i-th idx1​0…0 Ma trận A được tìm bằng cách A⋅(10⋯001⋯0⋮⋮⋱⋮00⋯1)=(vtos−1(s0[:n])vtos−1(s0[n:])⋮vtos−1(s9[n:])) A\\cdot\\left(\\begin{array}{cccc} 1 &amp; 0 &amp; \\cdots &amp; 0\\\\ 0 &amp; 1 &amp; \\cdots &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\ 0 &amp; 0 &amp; \\cdots &amp; 1 \\end{array}\\right)=\\left(\\begin{array}{c} vtos^{-1}(s_{0}[:n])\\\\ vtos^{-1}(s_{0}[n:])\\\\ \\vdots\\\\ vtos^{-1}(s_{9}[n:]) \\end{array}\\right)A⋅⎝⎜⎜⎜⎜⎛​10⋮0​01⋮0​⋯⋯⋱⋯​00⋮1​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​vtos−1(s0​[:n])vtos−1(s0​[n:])⋮vtos−1(s9​[n:])​⎠⎟⎟⎟⎟⎞​ Sau khi tìm được ma trận A (thực ra ở đây chúng ta phải transpose ma trận A một lần nữa), việc còn lại chỉ là tính encrypt(fakeflag2) và submit đáp án thôi :D. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import numpy as npfrom math import gcdfrom pwn import *def det(M): # stolen from https://stackoverflow.com/a/66192895 # make a copy to keep original M unmodified M = [[int(x) for x in row] for row in M] N, sign, prev = len(M), 1, 1 for i in range(N-1): if M[i][i] == 0: # swap with another row having nonzero i's elem swapto = next((j for j in range(i+1, N) if M[j][i] != 0), None) if swapto is None: return 0 # all M[*][i] are zero =&gt; zero determinant M[i], M[swapto], sign = M[swapto], M[i], -sign for j in range(i+1, N): for k in range(i+1, N): assert (M[j][k] * M[i][i] - M[j][i] * M[i][k]) % prev == 0 M[j][k] = (M[j][k] * M[i][i] - M[j][i] * M[i][k]) // prev prev = M[i][i] return sign * M[-1][-1]def stov(s): return np.array([ord(c)-32 for c in s])def vtos(v): return ''.join([chr(v[i]+32) for i in range(n)])def encrypt(s): return vtos(np.matmul(A, stov(s)) % 95)r = remote(&quot;lac.tf&quot;, 31140)n = 20r.recvline().decode().strip('\\n')f1 = r.recvline().decode().strip('\\n')f2 = r.recvline().decode().strip('\\n')print(&quot;f1 = &quot;, f1)print(&quot;f2 = &quot;, f2)en_str = []for i in range(0, n, 2): lst = list(chr(32) * (2 * n)) lst[i] = chr(33) lst[i + 1 + n] = chr(33) str = &quot;&quot;.join(lst) r.sendlineafter(&quot;Enter your guess: &quot;, str.encode('utf-8')) r.recvline().decode().strip('\\n') en_str.append(r.recvline().decode().strip('\\n')) en_str.append(r.recvline().decode().strip('\\n'))# Transpose matrix AB = [list(str) for str in en_str]A = [list(str) for str in en_str]for i in range(n): for j in range(n): A[i][j] = (ord(B[j][i]) - 32) % 95d = det(A)assert (gcd(d, 95) == 1)fakeflag2 = r.recvline_startswith(b'l').decode().strip('\\n')assert (len(fakeflag2) == 40)print(&quot;fakeflag2 = &quot;, fakeflag2)f3 = encrypt(fakeflag2[:n])f4 = encrypt(fakeflag2[n:])print(&quot;f3 = &quot;, f3)print(&quot;f4 = &quot;, f4)r.sendlineafter(&quot;Enter the first half: &quot;, f3.encode('utf-8'))r.sendlineafter(&quot;Enter the second half: &quot;, f4.encode('utf-8'))r.recvline().decode().strip('\\n')r.recvline().decode().strip('\\n')flag = r.recvline().decode().strip('\\n')print(&quot;Flag = &quot;, flag) 1Flag = lactf{tHeY_SaiD_l!NaLg_wOuLD_bE_fUN_115}","link":"/2023/la-ctf-2023-write-ups/"},{"title":"NSUCRYPTO 2022 Write-ups","text":"Mình cũng chỉ mới biết đến cuộc thi này gần đây thôi. Đây sẽ là nơi mình trình bày lời giải của một số bài trong cuộc thi NSUCRYPTO năm 2022. 1B.3 Face-to-face Link đề bài: https://nsucrypto.nsu.ru/archive/2022/round/1/section/2/task/3/#data Alice picked a new pin code (4 pairwise distinct digits from {1,…,9}\\{ 1,\\ldots,9 \\}{1,…,9}) for her credit card such that all digits have the same parity and are arranged in increasing order. Bob and Charlie wanted to guess her pin code. Alice said that she can give each of them a hint but face-to-face only.Bob alone came to Alice and she told him that the sum of her pin code digits is equal to the number of light bulbs in the living room chandelier. Bob answered that there is still no enough information for him to guess the code, and left. After that, Charlie alone came to Alice and she told him that if we find the product of all pin code digits and then sum up digits of those product, this result number would be equal to the amount of books on the shelf. Charlie also answered that there is still no enough information for him to guess the code, and left.Unfortunately, Eve was eavesdropping in the next apartment and, after Charlie had left, she immediately found out Alice pin code despite that she had never seen those chandelier and bookshelf. Could you find the pin code too? Bởi vì 4 số trong mã pin nằm trong khoảng {1,…,9}\\{ 1, \\ldots, 9 \\}{1,…,9}, có cùng tính chẵn lẻ, được sắp xếp theo thứ tự tăng dần, nên tập giá trị khả năng của mã pin là {1357,1359,1379,1579,3579,2468} \\{ 1357, 1359, 1379, 1579, 3579, 2468 \\}{1357,1359,1379,1579,3579,2468} Dựa theo thông tin do Alice cung cấp: Tập giá trị khả năng của Bob: {1379,2468}\\{ 1379, 2468 \\}{1379,2468} Tập giá trị khả năng của Charlie: {1359,1379,1579,3579}\\{ 1359, 1379, 1579, 3579 \\}{1359,1379,1579,3579} Lấy giao tập hợp khả năng nói trên, ta thu được mã pin của Alice là 1379. 1B.4 Matrix and reduction Link đề bài: https://nsucrypto.nsu.ru/archive/2022/round/1/section/2/task/4/#data Ban đầu chúng ta cần phải tìm encryption matrix F=(aij)∈(Z30)2,2F=(a_{ij}) \\in (\\mathbb{Z}_{30})_{2,2}F=(aij​)∈(Z30​)2,2​. Theo điều kiện bài toán: (a1,1a1,2a2,1a2,2)⋅(5171422)=(29132210) \\left(\\begin{array}{cc} a_{1,1} &amp; a_{1,2}\\\\ a_{2,1} &amp; a_{2,2} \\end{array}\\right)\\cdot\\left(\\begin{array}{cc} 5 &amp; 17\\\\ 14 &amp; 22 \\end{array}\\right)=\\left(\\begin{array}{cc} 29 &amp; 13\\\\ 22 &amp; 10 \\end{array}\\right)(a1,1​a2,1​​a1,2​a2,2​​)⋅(514​1722​)=(2922​1310​) Phương trình trên tương đương với phương trình (5140017220000514001722)⋅(a1,1a1,2a2,1a2,2)=(29132210) \\left(\\begin{array}{cccc} 5 &amp; 14 &amp; 0 &amp; 0\\\\ 17 &amp; 22 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 5 &amp; 14\\\\ 0 &amp; 0 &amp; 17 &amp; 22 \\end{array}\\right)\\cdot\\left(\\begin{array}{c} a_{1,1}\\\\ a_{1,2}\\\\ a_{2,1}\\\\ a_{2,2} \\end{array}\\right)=\\left(\\begin{array}{c} 29\\\\ 13\\\\ 22\\\\ 10 \\end{array}\\right)⎝⎜⎜⎜⎛​51700​142200​00517​001422​⎠⎟⎟⎟⎞​⋅⎝⎜⎜⎜⎛​a1,1​a1,2​a2,1​a2,2​​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​29132210​⎠⎟⎟⎟⎞​ Giải phương trình trên, ta thu được 4 nghiệm: F=(a1,1a1,2a2,1a2,2)∈{(3123),(31218),(31623),(316218)} F=\\left(\\begin{array}{cc} a_{1,1} &amp; a_{1,2}\\\\ a_{2,1} &amp; a_{2,2} \\end{array}\\right)\\in\\left\\{ \\left(\\begin{array}{cc} 3 &amp; 1\\\\ 2 &amp; 3 \\end{array}\\right),\\left(\\begin{array}{cc} 3 &amp; 1\\\\ 2 &amp; 18 \\end{array}\\right),\\left(\\begin{array}{cc} 3 &amp; 16\\\\ 2 &amp; 3 \\end{array}\\right),\\left(\\begin{array}{cc} 3 &amp; 16\\\\ 2 &amp; 18 \\end{array}\\right)\\right\\} F=(a1,1​a2,1​​a1,2​a2,2​​)∈{(32​13​),(32​118​),(32​163​),(32​1618​)} Đánh số các matrix trên lần lượt là F1,F2,F3,F4F_{1},F_{2},F_{3},F_{4}F1​,F2​,F3​,F4​. Chúng ta sẽ lần lượt xét từng trường hợp để tìm encryption matrix và plaintext đúng: F=F1F=F_1F=F1​. Vì matrix F1F_1F1​ khả nghịch nên ta tìm được (F1)−1=(91749) \\left(F_{1}\\right)^{-1}=\\left(\\begin{array}{cc} 9 &amp; 17\\\\ 4 &amp; 9 \\end{array}\\right)(F1​)−1=(94​179​) và plaintext ban đầu lúc này là: GOODLUCKFORWIN!! Với F2,F3,F4F_{2},F_{3},F_{4}F2​,F3​,F4​ cách làm tương tự, nhưng mình nghĩ đã tìm ra đáp đúng. 2.5. Super dependent S-box Link đề bài: https://nsucrypto.nsu.ru/archive/2022/round/2/task/5/#dataHarry wants to find a super dependent S-box for his new cipher. He decided to use a permutation that is strictly connected with every of its variables. He tries to estimate the number of such permutations.A vectorial Boolean function F(x)=(f1(x),f2(x),…,fn(x))F(x)=(f_1(x),f_2(x),\\ldots,f_n(x))F(x)=(f1​(x),f2​(x),…,fn​(x)), where x∈F2nx\\in \\mathbb{F}_2^nx∈F2n​, is a permutation on F2n\\mathbb{F}_2^nF2n​ if it is a one-to-one mapping on the set F2n\\mathbb{F}_2^nF2n​. Its coordinate function fk(x)f_k(x)fk​(x) (that is a Boolean function from F2n\\mathbb{F}_2^nF2n​ to F2\\mathbb{F}_2F2​), essentially depends on the variable xjx_jxj​ if there exist values b1,b2,…,bj−1,bj+1,…,bn∈F2b_1, b_2, \\ldots, b_{j-1}, b_{j+1}, \\ldots, b_n \\in \\mathbb{F}_2b1​,b2​,…,bj−1​,bj+1​,…,bn​∈F2​ such that fk(b1,b2,…,bj−1,0,bj+1,…,bn)≠fk(b1,b2,…,bj−1,1,bj+1,…,bn)f_k(b_1, b_2, \\ldots, b_{j-1}, 0, b_{j+1}, \\ldots, b_n) \\not = f_k(b_1, b_2, \\ldots, b_{j-1}, 1, b_{j+1}, \\ldots, b_n)fk​(b1​,b2​,…,bj−1​,0,bj+1​,…,bn​)=fk​(b1​,b2​,…,bj−1​,1,bj+1​,…,bn​) In other words, the essential dependence on the variable xjx_{j}xj​ of a function fff means the presence of xjx_{j}xj​ in the algebraic normal form of fff (the unique representation of a function in the basis of binary operations AND, XOR, and constants 0 and 1).An example. Let n=3n=3n=3. Then the Boolean function f(x1,x2,x3)=x1x2⊕x3f(x_1, x_2, x_3) = x_1 x_2 \\oplus x_3f(x1​,x2​,x3​)=x1​x2​⊕x3​ essentially depends on all its variables; but g(x1,x2,x3)=x1x2⊕x1⊕1g(x_1, x_2, x_3) = x_1 x_2 \\oplus x_1 \\oplus 1g(x1​,x2​,x3​)=x1​x2​⊕x1​⊕1 essentially depends only on x1x_1x1​ and x2x_2x2​.The problem. Find the number of permutations on F2n\\mathbb{F}_2^nF2n​ such that all their coordinate functions essentially depend on variables. Mình sẽ sử dụng định lý từ lý thuyết Automat (Automata theory) như sau: A vectorial Boolean function F(x‾)=(f1(x‾),f2(x‾),…,fn(x‾))F(\\overline{x})=(f_1(\\overline{x}),f_2(\\overline{x}),\\ldots,f_n(\\overline{x}))F(x)=(f1​(x),f2​(x),…,fn​(x)), where x‾∈F2n\\overline{x} \\in \\mathbb{F}_2^nx∈F2n​, is a permutation on F2n\\mathbb{F}_2^n F2n​ ⇔∀ (a1,a2,…,an)∈F2n∖(0,…,0) ⁣:a1f1(x‾)⊕a2f2(x‾)⊕…⊕anfn(x‾)\\Leftrightarrow \\forall \\; (a_1, a_2, \\ldots, a_n) \\in \\mathbb{F}_2^n \\setminus (0,\\ldots,0) \\colon a_1 f_1(\\overline{x}) \\oplus a_2 f_2(\\overline{x}) \\oplus \\ldots \\oplus a_n f_n(\\overline{x}) ⇔∀(a1​,a2​,…,an​)∈F2n​∖(0,…,0):a1​f1​(x)⊕a2​f2​(x)⊕…⊕an​fn​(x) - balanced boolean function. Đầu tiên mình sẽ tìm số lượng boolean function φ ⁣:F2n→F2\\varphi \\colon \\mathbb{F}_2^n \\rightarrow \\mathbb{F}_2φ:F2n​→F2​ thỏa mãn 2 điều kiện: φ\\varphi φ - balanced boolean function; φ\\varphi φ - essentially depends on all variables; Giả sử φ(0,…,0)=0\\varphi (0,\\ldots,0) = 0φ(0,…,0)=0. Do φ\\varphi φ hoàn toàn phụ thuộc vào tất cả n biến, do đó trong bảng chân trị (truth table) của hàm φ\\varphi φ sẽ có dạng như sau: ∀ x‾∈F2n\\forall \\;\\overline{x} \\in \\mathbb{F}_2^n∀x∈F2n​ φ(x‾)={0,∥x‾∥≡0 (mod 2)1,∥x‾∥≡1 (mod 2) \\varphi (\\overline{x}) = \\begin{cases} 0, &amp; \\Vert\\overline{x}\\Vert\\equiv 0 \\; (mod \\;2)\\\\ 1, &amp;\\Vert\\overline{x}\\Vert\\equiv 1 \\; (mod \\;2) \\end{cases}φ(x)={0,1,​∥x∥≡0(mod2)∥x∥≡1(mod2)​ Chú ý rằng, theo tính chất của binomial coefficient: ∥φ∥=(n1)+(n3)+…=2n−1 \\Vert \\varphi \\Vert = \\binom{n}{1} + \\binom{n}{3} + \\ldots = 2^{n-1} ∥φ∥=(1n​)+(3n​)+…=2n−1 Do đó chúng ta tìm được hàm φ1\\varphi_1φ1​ thỏa mãn tính chất cần tìm. Đối với trường hợp φ(0,…,0)=1\\varphi (0,\\ldots,0) = 1φ(0,…,0)=1, chúng ta thu được hàm φ2=φ1⊕1\\varphi_2 = \\varphi_1 \\oplus 1φ2​=φ1​⊕1 và đối với bất kỳ n∈Nn \\in \\mathbb{N}n∈N, tìm được chỉ 2 hàm φ1\\varphi_1φ1​ và φ2\\varphi_2φ2​ thỏa mãn tính chất cần tìm.Sử dụng định lý ban đầu, chúng ta dễ dàng kết luận rằng không tồn tại hàm F(x‾) ⁣:F2n→F2nF(\\overline{x}) \\colon \\mathbb{F}_2^n \\rightarrow \\mathbb{F}_2^n F(x):F2n​→F2n​ cần tìm. 2.11. A long-awaited event Link đề bài: https://nsucrypto.nsu.ru/archive/2022/round/2/task/11/#data Đầu tiên chúng ta sẽ tìm hệ số a,b,ca, b, ca,b,c của hàm mã hóa E(x)=f(x)=ax2+bx+c (mod 37)E(x) = f(x) = ax^2 + bx + c \\;( \\text{mod } 37)E(x)=f(x)=ax2+bx+c(mod 37). Với bất kỳ số nguyên x,yx, yx,y hàm fff thỏa mãn điều kiện: f(x−y)−2f(x)f(y)+f(1+xy)≡1 (mod 37).(1) f(x - y) - 2 f(x) f(y) + f(1 + x y) \\equiv 1 \\; ( \\text{mod } 37). \\qquad (1)f(x−y)−2f(x)f(y)+f(1+xy)≡1(mod 37).(1) Thay lần lượt giá trị (x,y)={(1,0),(0,1),(0,0)}(x,y) = \\{ (1,0), (0,1) , (0,0) \\}(x,y)={(1,0),(0,1),(0,0)} vào phương trình (1)(1)(1), ta thu được 3 phương trình: f(1)−2f(1)f(0)+f(1)≡1 (mod 37);(2) f(1) - 2 f(1) f(0) + f(1) \\equiv 1 \\; ( \\text{mod } 37); \\qquad (2)f(1)−2f(1)f(0)+f(1)≡1(mod 37);(2) f(−1)−2f(0)f(1)+f(1)≡1(mod 37);(3) f(-1) - 2 f(0) f(1) + f(1) \\equiv 1 ( \\text{mod } 37); \\qquad (3)f(−1)−2f(0)f(1)+f(1)≡1(mod 37);(3) f(0)−2f(0)f(0)+f(1)≡1(mod 37);(4) f(0) - 2 f(0) f(0) + f(1) \\equiv 1 (\\text{mod } 37) ; \\qquad (4)f(0)−2f(0)f(0)+f(1)≡1(mod 37);(4) Từ phương trình (2)(2)(2) và (3)(3)(3) suy ra f(1)≡f(−1) (mod 37)f(1) \\equiv f(-1) \\; ( \\text{mod } 37)f(1)≡f(−1)(mod 37) và b≡0 (mod 37)b \\equiv 0 \\; ( \\text{mod } 37)b≡0(mod 37). Từ phương trình (4)(4) (4) suy ra f(1)≡2f2(0)+1−f(0)(mod 37) (5)f(1) \\equiv 2 f^2(0) + 1 - f(0) (\\text{mod } 37) \\; (5)f(1)≡2f2(0)+1−f(0)(mod 37)(5), thay vào phương trình (2) ⁣:(2) \\colon(2): 2(2f2(0)+1−f(0))(1−f(0))≡2(2c2+1−c)(1−c)≡1(mod 37)(6) 2 (2 f^2(0) + 1 - f(0)) (1 - f(0)) \\equiv 2 (2 c^2 + 1 -c) (1 - c) \\equiv 1 (\\text{mod } 37) \\quad (6)2(2f2(0)+1−f(0))(1−f(0))≡2(2c2+1−c)(1−c)≡1(mod 37)(6) Ta tìm ra được c∈{16,19,22}c \\in \\{ 16, 19, 22 \\}c∈{16,19,22}. Từ phương trình (5)(5) (5) suy ra a≡2c2+1−2c(mod 37)a \\equiv 2c^2 + 1 - 2c (\\text{mod } 37)a≡2c2+1−2c(mod 37). Với giá trị c∈{16,22}c \\in \\{ 16, 22 \\}c∈{16,22} cho kết quả a=0a = 0a=0 (sai). Do đó c=19,a=19c = 19 , a = 19c=19,a=19. Hàm mã hóa có dạng như sau: E(x)=f(x)=19x2+19 (mod 37) E(x) = f(x) = 19x^2 + 19 \\;(\\text{mod } 37)E(x)=f(x)=19x2+19(mod 37) Bảng ánh xạ của hàm fff được trình bày như sau: Decode thông qua bảng 2: Đáp án: NSUCRYPTO 2022","link":"/2023/nsucrypto-2022-write-ups/"},{"title":"WolvCTF 2023 Write-ups","text":"Lại là mình pinox đây :D Giải lần này mình làm được 4/5 bài Crypto (mảng chính của mình), mình đồng thời cũng làm được một số bài ở mảng khác, cũng khá là may mắn. Dưới đây là write-up của mình về những bài mình đã làm được (Chỉ Crypto). Sanity Check (50) Join the Discord and read the rules! 1wctf{w3lc0m3_t0_w0lvctf_2023} Begineryowhatsthepassword (50) hey I lost the password :( main.py1234567891011121314151617181920212223# I'm thinking of a number from 0 to 2^32 - 1# Can you guess it?import randomdef generate(seed): random.seed(seed) c = 0 while c != ord('}'): c = random.randint(97, 126) print(chr(c), end='') print()secret = 'ly9ppw=='import base64s = int(input(&quot;password? &gt;&gt;&gt; &quot;))if int(base64.b64decode(secret).hex(), 16) == s: generate(s)else: print('nope') Bài dành cho beginner nên cũng không có gì cả, đơn giản là decode secret ra số là được. 1wctf{ywtp} theyseemerolling (50) they hatin my cryptosystem enc.py12345678910111213141516171819202122from Crypto.Util.strxor import strxorfrom Crypto.Util.number import long_to_bytesimport oskey = os.urandom(8)def encrypt_block(block): return strxor(key, block)def encrypt(pt): ct = b'' for i in range(0, len(pt), 4): index = long_to_bytes(i // 4) index = b'\\x00' * (4 - len(index)) + index ct += encrypt_block(index + pt[i:i+4]) return ctif __name__ == '__main__': flag = open('flag', 'rb').read() flag += b'\\x00' * (4 - len(flag) % 4) print(encrypt(flag).hex()) Chỉ là 1 bài XOR Trick đơn giản. solver.py123456789101112131415from Crypto.Util.strxor import strxorknown_pt = b&quot;\\x00\\x00\\x00\\x00wctf&quot;def encrypt_block(k, block): return strxor(k, block)ct = bytes.fromhex(&quot;983f687f03f884a9983f687e0ff2afbc983f687d03a891bd983f687c2bf68990983f687b04e9c0a9983f687a2be8c4a6983f687910c482ff983f687818f7afb6983f687744ee8290983f687644ec9e90983f687517e989bf983f687400ab8dcf&quot;)key = encrypt_block(ct[:8], known_pt)pt = b&quot;&quot;for i in range(0, len(ct),8): pt += encrypt_block(key, ct[i: i + 8])[4:]print(pt) 1wctf{i_sw3ar_my_pr0f_s4id_r0ll_y0ur_0wn_crypt0} We Will Rock You (50) Hey! Here’s the code for your free tickets to the rock concert! I just can’t remember what I made the password… Sử dụng công cụ fcrackzip và wordlist rockyou.txt để brute: 1fcrackzip -v -D -u -p /usr/share/wordlists/rockyou.txt we_will_rock_you.zip 1wctf{m1cH1g4n_4_3v3R} Cryptokeyexchange (127) Diffie-Hellman is secure rightnc keyexchange.wolvctf.io 1337 challenge.py12345678910111213141516171819202122#!/opt/homebrew/bin/python3from Crypto.Util.strxor import strxorfrom Crypto.Util.number import *from Crypto.Cipher import AESn = getPrime(512)s = getPrime(256)a = getPrime(256)# n can't hurt me if i don't tell youprint(pow(s, a, n))b = int(input(&quot;b? &gt;&gt;&gt; &quot;))secret_key = pow(pow(s, a, n), b, n)flag = open('/flag', 'rb').read()key = long_to_bytes(secret_key)enc = strxor(flag + b'\\x00' * (len(key) - len(flag)), key)print(enc.hex()) Trick rất đơn giản: chọn b=1b = 1b=1 và chúng ta có ngay secret_key. 123456789101112from pwn import *from Crypto.Util.number import long_to_bytesfrom Crypto.Util.strxor import strxorr = remote(&quot;keyexchange.wolvctf.io&quot;, 1337)r.recvline().decode().strip()key = long_to_bytes(int(r.recvline().decode().strip(), 10))r.sendlineafter(b&quot;b? &gt;&gt;&gt; &quot;, b'1')ct = bytes.fromhex(r.recvline().decode().strip())flag = strxor(ct, key)print(flag) 1wctf{m4th_1s_h4rd_but_tru5t_th3_pr0c3ss} Z2kDH (466) Sick of how slow it is to take the modulus of a large prime number? Tired of performing exponentiation over some weird group like ed25519? Just use the integers mod 2^k group with the unit g = 5! Efficient, reliable, doesn’t require any hard math! Tác giả của comment trong link đã giải thích chi tiết về thuật toán nên mình không giải thích nhiều nữa. 123456789101112131415161718192021222324252627282930from Crypto.Util.number import long_to_bytesmodulus = 1 &lt;&lt; 258e = 256def get_secret_key(pulic_key): s = [] for i in range (1, 257): b = 0 for j in range(len(s)): b = b * 2 + s[len(s) - 1 - j] ba = pow(pow(5, b, modulus), 1 &lt;&lt; (e - i), modulus) if pow(pulic_key, 1 &lt;&lt; (e - i), modulus) == ba: s.append(0) else: s.append(1) s = s[::-1] out = 0 for bit in s: out = (out &lt;&lt; 1) | bit return outpa = int(&quot;99edb8ed8892c664350acbd5d35346b9b77dedfae758190cd0544f2ea7312e81&quot;, 16) * 4 + 1pb = int(&quot;40716941a673bbda0cc8f67fdf89cd1cfcf22a92fe509411d5fd37d4cb926afd&quot;, 16) * 4 + 1sb = get_secret_key(pb)shared_key = pow(pa, sb, modulus) // 4print(long_to_bytes(shared_key)) 1wctf{P0HL1G_H3LLM4N_$M4LL_pr1M3} Galois-t is this? (495) I’m expecting a super secret message… If you can give it to me, I’ll give you a flag!nc galois.wolvctf.io 1337 server.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#!/usr/bin/python3from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.number import *from Crypto.Util.strxor import *import osfrom pathlib import Pathdef GF_mult(x, y): product = 0 for i in range(127, -1, -1): product ^= x * ((y &gt;&gt; i) &amp; 1) x = (x &gt;&gt; 1) ^ ((x &amp; 1) * 0xE1000000000000000000000000000000) return productdef H_mult(H, val): product = 0 for i in range(16): product ^= GF_mult(H, (val &amp; 0xFF) &lt;&lt; (8 * i)) val &gt;&gt;= 8 return productdef GHASH(H, A, C): C_len = len(C) A_padded = bytes_to_long(A + b'\\x00' * (16 - len(A) % 16)) if C_len % 16 != 0: C += b'\\x00' * (16 - C_len % 16) tag = H_mult(H, A_padded) for i in range(0, len(C) // 16): tag ^= bytes_to_long(C[i*16:i*16+16]) tag = H_mult(H, tag) tag ^= bytes_to_long((8*len(A)).to_bytes(8, 'big') + (8*C_len).to_bytes(8, 'big')) tag = H_mult(H, tag) return tagFLAG = &quot;wctf{This_is_fake_flag}&quot;# 128-bit blocksAES_BLOCK_SIZE = 16key = get_random_bytes(16)header = b'WolvCTFCertified'message = b'heythisisasupersecretsupersecret'used_nonces = set()def incr(counter): temp = bytes_to_long(counter) return long_to_bytes(temp + 1, 16)[-16:]def check_nonce(nonce): # if you can't reuse the nonce, surely you can't explot this oracle! if(nonce in used_nonces): print(&quot;Sorry, a number used once can't be used twice!&quot;) exit(0) used_nonces.add(nonce)def encrypt(nonce, pt): pt = bytes.fromhex(pt) assert(len(pt) % 16 == 0) numBlocks = len(pt) // AES_BLOCK_SIZE if(numBlocks &gt; 3): print(&quot;Sorry, we just don't have the resources to encrypt a message that long!&quot;) exit(0) nonce = bytes.fromhex(nonce) assert(len(nonce) == 16) check_nonce(nonce) cipher = AES.new(key, AES.MODE_ECB) hkey = cipher.encrypt(b'\\0' * 16) enc = b'' for i in range(numBlocks + 1): enc += cipher.encrypt(nonce) # the counter is just the nonce, right? right?? nonce = incr(nonce) ct = b'' for i in range(1, numBlocks + 1): ct += strxor( enc[i * AES_BLOCK_SIZE: (i+1) * AES_BLOCK_SIZE], pt[(i-1) * AES_BLOCK_SIZE: i * AES_BLOCK_SIZE]) authTag = strxor( enc[:AES_BLOCK_SIZE], long_to_bytes(GHASH(bytes_to_long(hkey), header, ct))) return ct.hex(), authTag.hex()def decrypt(nonce, ct, tag): ct = bytes.fromhex(ct) assert(len(ct) % 16 == 0) numBlocks = len(ct) // AES_BLOCK_SIZE nonce = bytes.fromhex(nonce) assert(len(nonce) == 16) check_nonce(nonce) tag = bytes.fromhex(tag) assert(len(tag) == 16) cipher = AES.new(key, AES.MODE_ECB) hkey = cipher.encrypt(b'\\0' * 16) enc = b'' for i in range(numBlocks + 1): enc += cipher.encrypt(nonce) # the counter is just the nonce, right? nonce = incr(nonce) pt = b'' for i in range(1, numBlocks + 1): pt += strxor( enc[i * AES_BLOCK_SIZE: (i+1) * AES_BLOCK_SIZE], ct[(i-1) * AES_BLOCK_SIZE: i * AES_BLOCK_SIZE]) authTag = strxor( enc[:AES_BLOCK_SIZE], long_to_bytes(GHASH(bytes_to_long(hkey), header, ct))) if(pt == message): if(authTag == tag): print(FLAG) else: print(&quot;Whoops, that doesn't seem to be authentic!&quot;) else: print(&quot;Hmm, that's not the message I was looking for...&quot;)MENU = &quot;&quot;&quot;1. Encrypt2. Submit3. Exit&quot;&quot;&quot;def main(): print(&quot;If you can send me a valid super secret super secret I'll give you a reward!&quot;) while len(used_nonces) &lt; 3: print(MENU) command = input(&quot;&gt; &quot;) match command: case &quot;1&quot;: nonce = input(&quot;IV (hex) &gt; &quot;) pt = input(&quot;Plaintext (hex) &gt; &quot;) ct, tag = encrypt(nonce, pt) print(&quot;CT: &quot;, ct) print(&quot;TAG: &quot;, tag) case &quot;2&quot;: nonce = input(&quot;IV (hex) &gt; &quot;) ct = input(&quot;Ciphertext (hex) &gt; &quot;) tag = input(&quot;Tag (hex) &gt; &quot;) decrypt(nonce, ct, tag) exit(0) case other: print(&quot;Bye!&quot;) exit(0) print(&quot;I know encryption is fun, but you can't just keep doing it...&quot;) if __name__ == &quot;__main__&quot;: main() Bài này thuộc kiểu XOR Trick, đề bài khá dài, tóm tắt như sau: Server cho chúng ta 3 lựa chọn: Encrypt: Mã hóa pt với IV biết trước, trả về ct và AuthTag. Decrypt: Nhập IV, ct và AuthTag, kiểm tra nếu ct == pt biết trước và AuthTag chính xác khi mã hóa pt với IV thì trả về Flag. Exit: Dừng cuộc chơi. Đọc sơ qua về file mã nguồn, ta tóm tắt được như sau: (đối với trường hợp len(pt) = 32 bytes) Cipher text ct có dạng: ct=pt⊕E(IV+1)∥E(IV+2) ct=pt\\oplus E(IV+1)\\parallel E(IV+2)ct=pt⊕E(IV+1)∥E(IV+2) AuthTag có dạng: tag=E(IV)⊕HASH(E(0‾),header,ct) tag=E(IV)\\oplus HASH\\left(E(\\overline{0}),header,ct\\right)tag=E(IV)⊕HASH(E(0),header,ct) Với lựa chọn pt và IV hợp lý (ta được phép chọn 2 lần), ta có thể tìm được giá trị và tìm được ct và AuthTag tương ứng. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *def gen_checkTag(i0, i1, i2, i3): ct = b'' ct += i2 + i3 ct = strxor(ct, message) authTag = strxor(i1, long_to_bytes(GHASH(bytes_to_long(i0), header, ct))) return ct.hex(), authTag.hex()header = b'WolvCTFCertified'hex_pt = &quot;6865797468697369736173757065727365637265747375706572736563726574&quot; message = b'heythisisasupersecretsupersecret' r = remote(&quot;galois.wolvctf.io&quot;, 1337)_iv0 = &quot;ffffffffffffffffffffffffffffffff&quot;r.sendlineafter(b&quot;&gt; &quot;, b'1')r.sendlineafter(b&quot;IV (hex) &gt; &quot;, _iv0)r.sendlineafter(b&quot;Plaintext (hex) &gt; &quot;, hex_pt)ct1 = bytes.fromhex(r.recvline().decode().strip()[4:])tg1 = bytes.fromhex(r.recvline().decode().strip()[5:])_iv2 = &quot;00000000000000000000000000000002&quot;r.sendlineafter(b&quot;&gt; &quot;, b'1')r.sendlineafter(b&quot;IV (hex) &gt; &quot;, _iv2)r.sendlineafter(b&quot;Plaintext (hex) &gt; &quot;, hex_pt)ct3 = bytes.fromhex(r.recvline().decode().strip()[4:])tg3 = bytes.fromhex(r.recvline().decode().strip()[5:])iv0 = strxor(ct1[:16], message[:16])iv1 = strxor(ct1[16:], message[16:])iv3 = strxor(ct3[:16], message[:16])iv4 = strxor(ct3[16:], message[16:])iv2 = strxor(tg3, long_to_bytes(GHASH(bytes_to_long(iv0), header, ct3)))ct4, tag = gen_checkTag(iv0, iv1, iv2, iv3)_iv1 = &quot;00000000000000000000000000000001&quot;r.sendlineafter(b&quot;&gt; &quot;, b'2')r.sendlineafter(b&quot;IV (hex) &gt; &quot;, _iv1)r.sendlineafter(b&quot;Ciphertext (hex) &gt; &quot;, ct4.encode())r.sendlineafter(b&quot;Tag (hex) &gt; &quot;, tag.encode())flag = r.recvline().decode().strip()print(flag) 1wctf{th13_sup3r_s3cr3t_13nt_v3ry_s3cr3t} DownUnder (497) I sure hope nobody goes down on me… Make sure to gobble down our cookies though.https://down-under-tlejfksioa-ul.a.run.app/ key_exchange.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from flask import Flask, request, jsonifyfrom json import loadsfrom Crypto.Util.number import long_to_bytes, bytes_to_longfrom hashlib import sha256from hmac import newfrom uuid import uuid4from generate import generateapp = Flask(__name__)key = { '0' : 0 , '1' : 1 , '2' : 2 , '3' : 3 , '4' : 4 , '5' : 5 , '6' : 6 , 'a' : 70, 'b' : 71, 'c' : 72, 'd' : 73, 'e' : 74, 'f' : 75, 'g' : 76, 'h' : 77, 'i' : 78, 'j' : 79, 'k' : 80, 'l' : 81, 'm' : 82, 'n' : 83, 'o' : 84, 'p' : 85, 'q' : 86, 'r' : 87, 's' : 88, 't' : 89, 'u' : 90, 'v' : 91, 'w' : 92, 'x' : 93, 'y' : 94, 'z' : 95, '_' : 96, '{' : 97, '}' : 98, '!' : 99, }sessions = {}def bytes_to_long_flag(bytes_in): long_out = '' for b in bytes_in: long_out += str(key[chr(b)]) return int(long_out)def long_to_bytes_flag(long_in): new_map = {v: k for k, v in key.items()} list_long_in = [int(x) for x in str(long_in)] str_out = '' i = 0 while i &lt; len(list_long_in): if list_long_in[i] &lt; 7: str_out += new_map[list_long_in[i]] else: str_out += new_map[int(str(list_long_in[i]) + str(list_long_in[i + 1]))] i += 1 i += 1 return str_out.encode(&quot;utf_8&quot;)def diffie_hellman(A, g, b, p): B = pow(g,b,p) s = pow(A,b,p) message = b'My totally secure message to Alice' password = long_to_bytes(s) my_hmac = new(key=password, msg = message, digestmod=sha256) return str(bytes_to_long(my_hmac.digest())), B@app.route(&quot;/&quot;)def home(): old_session = request.cookies.get('session') A = request.args.get('A', type = int) if not isinstance(A, int): return &quot;Missing required query string parameter: A&quot; if not old_session: p, q, g = generate() session = {&quot;id&quot;: uuid4().hex, 'p': p, 'q': q, 'g': g, &quot;attempts&quot;: 0} sessions[session['id']] = session else: if old_session not in sessions.keys(): return &quot;Invalid session&quot; if not sessions[old_session]['attempts'] &lt; 7: sessions.pop(old_session) return &quot;Too many attempts&quot; p, q, g, attempts = sessions[old_session]['p'], sessions[old_session]['q'], sessions[old_session]['g'], sessions[old_session]['attempts'] session = {&quot;id&quot;: old_session, 'p': p, 'q': q, 'g': g, &quot;attempts&quot;: attempts + 1} sessions[old_session] = session if b &gt; q: return &quot;Connection reset&quot; try: hmac, B = diffie_hellman(int(A), g, b, p) res = jsonify({&quot;hmac&quot;: hmac, &quot;B&quot;: B, &quot;p&quot;: p, &quot;q&quot;: q, &quot;g&quot;: g}) res.set_cookie('session', session['id']) return res except: return &quot;Internal error. A was: &quot; + str(A)f = open(&quot;flag.txt&quot;, &quot;r&quot;)flag = f.read().strip()b = bytes_to_long_flag(flag.encode('utf-8'))if __name__ == &quot;__main__&quot;: app.run(port=54321) Đọc qua thì đây lại là bài toán trao đổi khóa DHKE, tuy nhiên có một số điểm ta nhận thấy như sau: Khóa bí mật b được sử dụng nhiều lần. Độ lớn của bytes_to_long_flag(flag) không vượt quá q, ta suy ra độ dài của nó khoảng 40 chữ số. Số b−1b - 1b−1 có nhiều divisors nhỏ. Từ những dữ kiện này, ta nghĩ đến tấn công Pohlig–Hellman algorithm. Sử dụng những cặp số (g,gb,p)(g, g^b, p) (g,gb,p) khác nhau (ở đây mình sử dụng 2 bộ) và CRT, ta nhanh chóng thu được khóa bí mật b. 12345678910111213F_p = [36131,39161,43063,46073,50873,52301]r = []for t in F_p: q = (p - 1) // t B1 = pow(B, q, p) g1 = pow(g, q, p) for i in range(t): if pow(g1, i, p) == B1: r.append(i) breakprint(r) Sagemath1234567891011121314151617181920212223242526272829303132F_p = [36131,39161,43063,46073,50873,52301, 19515162859827511106451680926]r = [14792, 7728, 8980, 42070, 8849, 30172, 12902743557457970008807866582]b = crt(r, F_p)def bytes_to_long_flag(bytes_in): long_out = '' for b in bytes_in: long_out += str(key[chr(b)]) return int(long_out)def long_to_bytes_flag(long_in): new_map = {v: k for k, v in key.items()} list_long_in = [int(x) for x in str(long_in)] str_out = '' i = 0 while i &lt; len(list_long_in): if list_long_in[i] &lt; 7: str_out += new_map[list_long_in[i]] else: str_out += new_map[int(str(list_long_in[i]) + str(list_long_in[i + 1]))] i += 1 i += 1 return str_out.encode(&quot;utf_8&quot;)p = 2115635612788314680423759533842276142188937827456317028096065273041055870280642066275286948329121712229597609188471055831220265463326525301446163712834147940052647264097207891095916335380576244626451390262378673945402653142119950219013539405730812529850482244791237562998027g = 952301897016132751164848969282352795338459214964513051829166657742677405297778375105450145836227698217726356198830082748898262871130349651212793560505294122964009215059837865055555664469554395220315025018158971967825473597855461585261861881579238655661082289326040203660399B = 213835255108491136865266315094809652114336655580595797170157304518249974206632214632639652513153034456183165945205323136611249731490416068087034176061118409571433147412425165996209507835070376993149257720952113379997189998254838152926130137297097132727035544312965351461374b = 9272897597824931829082968138376897759998print(long_to_bytes_flag(b)) 1wctf{m4x1mum_l3ngth5!}","link":"/2023/wolv-ctf-2023-write-ups/"},{"title":"Pragyan CTF 2023 Write-ups","text":"Là mình pinox đây, giải Pragyan và giải Kalmar tổ chức ngay sau nhau, tuy nhiên giải này vào đầu tuần nên mình có ít thời gian để tham gia vì còn bận đi học :(( Tổng kết thì mình làm được 1 bài duy nhất là LeakyRSA, còn 2 bài Compromised và CustomAESed thì mình đã giải được một phần, khúc cuối mình không hiểu dữ kiện nên không làm tiếp được, chắc sẽ phải tham gia nhiều hơn để học hỏi kinh nghiệm. :(( Sanity Check (10) Read the rules for Pragyan CTF 2023 in our discord server for the flag 1p_ctf{pl34s3_f0ll0w_th3_rul3s} Leaky RSA (451) XOR-ing the two most important numbers for RSA will give you the XOR key.Files: cipher.txt, keys.txt cipher.txt103cbfb27971838e83245ff0ee4340491f81319c9c5122289f287c6439946de361e5b5a40bb25798ed0139a172f1003e0f4fd663ac2469b9706b29c267add203d3ddde4388d5633af534dba0ef838069bab465b9580567bc8aedf921688559e675c191c1ef8716a9e974bdf4f3f555ab4e4ab3a6a9457c8c250edde726a887e6e7e94a47cd40865b06811ef4dba6951cfa647089480577ac8afdf931788559f665d181d1ef9706b9e974adf4e3e545ab5e5ab3a6a9456c9c250ecde726a887f6e7f94a57dd50865b06810ef4dba6951cea646089481577ac8afde931689549f665d181c1ff9706a9f964bdf4e3e555ab4e4aa3b6a9556c9c251ecdf726b887f6f7e95a57cd40964b06810ef4cbb6950cea646099581577bc9aedf921789559f675d181d1ef9716a9e964ade4f3e545bb5e4aa3b6a9456c9c351ecde726a897e6e7f95a47dd50965b16911ee4cba6850cfa647089480567bc8afdf921789549f675d191d1ef9716a9e974bde4f3f545bb4e5aa3b6b9456c8c351ecdf726b887f6f7e94a47dd50865b16911ee4cba6850cfa747089580577bc9afdf931689559e665c181d1ff9706b9f964ade4e3f545bb4e5ab3b6b9457c8c250ecde736b887f6e7e95a57cd40965b16911ef4dbb6950cea747089580577ac9aedf921788549f665c181c1ff8716b9f974adf4e3e545ab4e5aa3b6b9557c9c351ecdf726a887e6e7e94a57dd50864b16910ef4dba6851cea746089580577ac9afdf931789559f665c191c1ff8706b9f964bdf4f3f545ab4e4ab3a6a9556c8c251ecde736b887f6e7f95a47cd50864b06911ee4dba6950cea747099580567bc9aede931689549f665c191c1ff8706a9f974ade4f3f545ab4e4aa3b6b9557c8c250edde726a897e6e7e94a57dd50865b16911ef4cba6851cea747089581577ac9afdf931688559f665d181c1ef8706a9e964adf4f3f555bb4e4aa3b6a9556c8c250ecde726b887e6f7e94a47dd40965b16811ee4dba6851cfa647099580567ac8aedf921788559f665d181c1ff9716b9f974ade4e3e555ab4e5aa3b6a9556c9c350edde726b887f6e7f94a57cd50965b16910ef4cbb6950cfa646099480567bc8afde921689549e665d181c1ef9716b9e974bdf4e3f555ab4e5aa3b6b9456c8c350ecdf736b897e6e7f94a47cd50865b16810ee4cbb6851cea647089580577bc8afde931789549f675d181d1ff9706b9e974bde4e3f545bb5e4ab3b6a9556c9c251edde736a887f6f7f94a57cd40965b06910ef4cbb6850cea646089481577bc9afdf931788559e675d181d1ef8706b9f964ade4e3f545ab5e4ab3a6b9457c8c350edde726b897e6f7e95a47cd40864b06810ef4dba6951cfa747089581577bc8afdf921788559e675c191c1ef8706b9f974bde4f3f555ab5e4ab3a6a9456c9c351ecde736b887e6e7f94a47cd40864b06910ee4cba6950cea647099480567bc8afdf931688549e675d181d1ff8716b9f964bde4f3e545ab5e4ab3a6a9456c9c251ecde726a887e6f7f95a57dd40965b06910ef4cbb6950cfa747 keys.txt123n=90622785163120637260087015941572725098110139248382612878945571071101519512487568042232671567664172893228075756497045498977699900942323326164843993553269528291618632246672608219867461615864060915805942735237995404948413293503561184020274098566470196075252508233670564868845603564225996537006792676270111655183e=65537d=15881146338685635884036488977050563006420723396976888000895522891673420382393452842898549414141981257590741871971078437459128177400896949829916432945653604999697231535449287553706229377750925398422163407130833254874911822837377080596876193928404120093555522404504384602474224038479487948631716643357270128113 Dựa vào gợi ý của đề bài, đầu tiên ta đi tìm 2 số p, q khi biết n, e, d (thuật toán trình bày ở đây). Sau khi tìm được 2 số p, q thỏa mãn, ta tìm được xor_key=q⊕pxor\\_key = q \\oplus pxor_key=q⊕p. Sử dụng xor_keyxor\\_keyxor_key vừa thu được, ta giải mã file ciphers.txt bằng cách XOR và thu được plain 12Looks like someone mutiplied &quot;password&quot; with the flag before encrypting.message=0b100010111110011111010011001110001111000010000100000111100100101100111110011110001010000111010100110000101001000111011100010000010111110010011001001111111111101110000111110111110010110010010000111000110011000010010100010000111100111010100010111100111111101100001111000100101001001000001111010111111101110011010011111111111010011010101100001011001000110101110010010101110011001000010111101100110101110101001001110111110010111110000101110000000110010110110110001111110110111100011000100101100101001001001011010101101000000010011111011110000001101100110000101001011101001011100111111101101111100111110101001010111001001011001100101101110110101010011011011110010000100011111111100010001101000101110000100110000000110110001001100000111011111101011011011000000101010110100011101011000001000000100010100000011000010000011001001110001011000101100110011000001110110010010000011110001110111000001100010011111110111101100111111010100011000011001110010000000000100111010010000011101100000001001110010100001100011010001011101110001001111 Đến đây thì mình bắt đầu suy nghĩ về dữ kiện mới :)), và về cipher RSA chưa sử dụng, sau nhiều lần thử thì mình đi đến kết luận rằng , ở đây là giá trị của “password” -&gt; hex -&gt; int :)). Còn lại là giải bình thường thôi. 1234567891011121314151617181920212223242526272829303132333435363738394041from math import gcdfrom pwn import xorn=90622785163120637260087015941572725098110139248382612878945571071101519512487568042232671567664172893228075756497045498977699900942323326164843993553269528291618632246672608219867461615864060915805942735237995404948413293503561184020274098566470196075252508233670564868845603564225996537006792676270111655183e=65537d=15881146338685635884036488977050563006420723396976888000895522891673420382393452842898549414141981257590741871971078437459128177400896949829916432945653604999697231535449287553706229377750925398422163407130833254874911822837377080596876193928404120093555522404504384602474224038479487948631716643357270128113p = 8090579019548651740169774893471409762905415187922576361313273217727161034444882205917051180880965304736581653032799951601902931351004322273094375585996887q = 11201025902368134933491342445834514167593639050571204653767361996077157225761247125637197847363122890891214577057215402210559002072464380051697200976473609xor_key = p ^ qprint(&quot;xor_key = &quot;, hex(xor_key)[2:])msg1 = &quot;03cbfb27971838e83245ff0ee4340491f81319c9c5122289f287c6439946de361e5b5a40bb25798ed0139a172f1003e0f4fd663ac2469b9706b29c267add203d3ddde4388d5633af534dba0ef838069bab465b9580567bc8aedf921688559e675c191c1ef8716a9e974bdf4f3f555ab4e4ab3a6a9457c8c250edde726a887e6e7e94a47cd40865b06811ef4dba6951cfa647089480577ac8afdf931788559f665d181d1ef9706b9e974adf4e3e545ab5e5ab3a6a9456c9c250ecde726a887f6e7f94a57dd50865b06810ef4dba6951cea646089481577ac8afde931689549f665d181c1ff9706a9f964bdf4e3e555ab4e4aa3b6a9556c9c251ecdf726b887f6f7e95a57cd40964b06810ef4cbb6950cea646099581577bc9aedf921789559f675d181d1ef9716a9e964ade4f3e545bb5e4aa3b6a9456c9c351ecde726a897e6e7f95a47dd50965b16911ee4cba6850cfa647089480567bc8afdf921789549f675d191d1ef9716a9e974bde4f3f545bb4e5aa3b6b9456c8c351ecdf726b887f6f7e94a47dd50865b16911ee4cba6850cfa747089580577bc9afdf931689559e665c181d1ff9706b9f964ade4e3f545bb4e5ab3b6b9457c8c250ecde736b887f6e7e95a57cd40965b16911ef4dbb6950cea747089580577ac9aedf921788549f665c181c1ff8716b9f974adf4e3e545ab4e5aa3b6b9557c9c351ecdf726a887e6e&quot;msg2 = &quot;7e94a57dd50864b16910ef4dba6851cea746089580577ac9afdf931789559f665c191c1ff8706b9f964bdf4f3f545ab4e4ab3a6a9556c8c251ecde736b887f6e7f95a47cd50864b06911ee4dba6950cea747099580567bc9aede931689549f665c191c1ff8706a9f974ade4f3f545ab4e4aa3b6b9557c8c250edde726a897e6e7e94a57dd50865b16911ef4cba6851cea747089581577ac9afdf931688559f665d181c1ef8706a9e964adf4f3f555bb4e4aa3b6a9556c8c250ecde726b887e6f7e94a47dd40965b16811ee4dba6851cfa647099580567ac8aedf921788559f665d181c1ff9716b9f974ade4e3e555ab4e5aa3b6a9556c9c350edde726b887f6e7f94a57cd50965b16910ef4cbb6950cfa646099480567bc8afde921689549e665d181c1ef9716b9e974bdf4e3f555ab4e5aa3b6b9456c8c350ecdf736b897e6e7f94a47cd50865b16810ee4cbb6851cea647089580577bc8afde931789549f675d181d1ff9706b9e974bde4e3f545bb5e4ab3b6a9556c9c251edde736a887f6f7f94a57cd40965b06910ef4cbb6850cea646089481577bc9afdf931788559e675d181d1ef8706b9f964ade4e3f545ab5e4ab3a6b9457c8c350edde726b897e6f7e95a47cd40864b06810ef4dba6951cfa747089581577bc8afdf921788559e675c191c1ef8706b9f974bde4f3f555ab5e4ab3a6a9456c9c351ecde736b887e6e&quot;msg3 = &quot;7f94a47cd40864b06910ee4cba6950cea647099480567bc8afdf931688549e675d181d1ff8716b9f964bde4f3e545ab5e4ab3a6a9456c9c251ecde726a887e6f7f95a57dd40965b06910ef4cbb6950cfa747&quot;pt = &quot;&quot;for i in range(0,len(msg1),128): num = int(msg1[i: i+128],16) res = num ^ xor_key pt += hex(res)[2:]for i in range(0,len(msg2),128): num = int(msg2[i: i+128],16) res = num ^ xor_key pt += hex(res)[2:]t1 = int(msg3[:128], 16)pt += hex(t1 ^ xor_key)[2:]t2 = hex(xor_key)[2:]pt += hex(int(msg3[128:], 16) ^ int(t2[:36],16))[2:]print(bytes.fromhex(pt).decode())message=0b100010111110011111010011001110001111000010000100000111100100101100111110011110001010000111010100110000101001000111011100010000010111110010011001001111111111101110000111110111110010110010010000111000110011000010010100010000111100111010100010111100111111101100001111000100101001001000001111010111111101110011010011111111111010011010101100001011001000110101110010010101110011001000010111101100110101110101001001110111110010111110000101110000000110010110110110001111110110111100011000100101100101001001001011010101101000000010011111011110000001101100110000101001011101001011100111111101101111100111110101001010111001001011001100101101110110101010011011011110010000100011111111100010001101000101110000100110000000110110001001100000111011111101011011011000000101010110100011101011000001000000100010100000011000010000011001001110001011000101100110011000001110110010010000011110001110111000001100010011111110111101100111111010100011000011001110010000000000100111010010000011101100000001001110010100001100011010001011101110001001111print(&quot;message = msg4 = &quot;, hex(message)[2:])msg4 = hex(message)[2:]m = msg4mm = pow(int(m,16),d,n)pas = int(&quot;70617373776f7264&quot;,16)print(bytes.fromhex(hex(mm // pas)[2:]).decode()) 1p_ctf{0n3_1eak_15_en0u6h_70_4774ck_rsa} Những bài dưới đây có bài mình làm được một phần, một bài mình không làm được. Sau giờ kết thúc thì với một vài hint đến từ người chơi trong server discord Pragyan CTF 2023, mình đã từng bước làm được và trình bày cách làm dưới đây. CustomAESed (500) Alice wanted a method to secure data that not only encrypts but also provides error correction capabilities to some extent.Help Bob read Alice’s message using encryption algorithm. Do not forget to wrap the flag in flag formatflag format: p_ctf{…}Hint 1: Try relating the encoding function with what is given in the question.Hint 2: If you are stuck at some point and can’t figure out how to proceed, google might be your best friend.File: encrypt.py encrypt.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from pwn import xorfrom hashlib import sha256from base64 import b64encodedef encryption(text, key, iv): assert len(iv) == 12 block_size = AES.block_size text = pad(text, block_size) encrypted = bytes() cipher = AES.new(key, AES.MODE_ECB) for n in range(1, (len(text) // block_size) + 1): num = bytes.fromhex(&quot;{0:08x}&quot;.format(n)) pt = iv[:8] + num + iv[8:] ct = cipher.encrypt(pt) encrypted += xor(text[(n - 1) * block_size: n * block_size], ct) return encrypteddef data_encoder(text): bin_text = bin(bytes_to_long(text))[2:] encoded_text = [] parity_bits = 0 x = 1 y = 0 while y &lt; len(bin_text): if x &amp; (x - 1) == 0: encoded_text.append('0') parity_bits += 1 else: encoded_text.append(bin_text[y]) y += 1 x += 1 for x in range(parity_bits): pos_bit = 0 for bit in range(1, len(encoded_text) + 1): if bit &amp; (2 ** x): pos_bit ^= int(encoded_text[bit - 1]) encoded_text[(2 ** x) - 1] = str(pos_bit) return (&quot;&quot;.join(encoded_text)).encode()pt = r&quot;--REDACTED--&quot;text = data_encoder(pt.encode())print(text.hex())key = sha256(&quot;128bit_secretkey&quot;.encode()).digest()iv = bytes.fromhex(&quot;1670dc9a0ed463028e1a7d68&quot;)ct = encryption(text, key, iv)ct = iv + ctprint(f&quot;ct = {b64encode(ct).decode()}&quot;)# ct = FnDcmg7UYwKOGn1ouDH/nxv55SuZ82NdZzh4IZoMs5q0PXEQu0wTJVF3uT2/IkK4ep2P3tFPyWRp+vSm4TOUhVXOn9EouV4BjaqfCHVM0/i8kPcWE2Ek2wziCCYS66XTrZRkS8T+/kRyqx6dEmUAWqyYKrVrCuGOR1hof1W1ApuX0xYVny+oZZFOH7xzsDKoW6sF7L0zv5R3iGBEo2+cSMRi5alzx2PMcPskGvS0edMFNSm0CpRndYnxb96MSF6cPIsqY8y1QngddCFR9xP7PRCYS3q4GExa844l9DJvAn613RSHNzbWuJaDuEjSil9EOuYxP9+vfCRZ2gKm3SEQqgk9F8a11ag4Yg04WLjgHaXjjU29hH1XJAzgAQ7IAtVQpL/2a0hwc3X9ugzyIZN1cC22eq5W8kb3DZMH2nzVFZBNe9+h/eYpSsy8wVOZt8CkV8JTqFt7hN4rL/zuFUTuDqCUhsCC9ELeJYHCYZgYW7r6M5AigTf4xC8ILlYga8kGPeAGjEsckhygJxLNvBy+YzplDDbygmc9gtymPyaX75EKJ/mLOJFdSq/BlMZi6C+1C5xFsCxcJ14zEH8oqWrUFlRj1wVWMvkCLDLvejP5DO42yN0MP5cHP+Fi4n2KF/cREcpIcLog1bvKBHzAyznV6IAfFHDXc2B2UDf9v6fI9k3USGSb/kBpWVjNYrvI05R50KtnLGLRCYYY349c5MjABYJDFXSvlMQNkJQqjcbts3aM0V3tXgMNyWzurahC/ZrUc3Ex2mAFOULtcWqSHHK4gWq5atZ1tpSGTMhhi5h+66AUK+5xFgBcWEB+g0R/a9MBBgS1lsZdA5gud1K91tk1gbrGV32hdUWjIpKsgDRW2cZfg8nM5wsWVjSTc9o7uoTqsAKkONf2EsEn228ih7XTig5DSkXqgT4/ArX4gaEQzB1px9mNSdMZG7pNfbq6/VNLTDnQdcRlB6uGYp99rOk8HjgYXun7hrB6WWcuTkgi0G54MrjPMpMbmTCuPSnWGG+LnmxkhqR6hd1PK26HpEwt62WD10OlKiJ6LilI/5RsQMDnhf4i+Bel7ZeYltIy9M09rKLa2i7+ZjiigUpuCudJNiv7OjxuQSH2YTiY3tHmcPgnQ5ycWUPdwEhT20ElvB3umlbjiI77FkiswUHjI2jXGn7xmOy46MYFBwt6aju2OxSy+fTyzAxIM4olurcWDOBt/0m1Xc3VQrwphr70eTIgGcx7a4MK9WIZciccGkD7tFE8kM6jvnYRi0Ib5W/xuXZkaJT3KVydI05NOUfUOGasxxOw4M3qGM1/nQifCqATrx4znVylUNixhM4WN26gl9XAQXqQewcdDA7/Hnc8aNmcBuSOgZs4gJjE8S9MyngdnZvUrU6owB5gU0O+1ZPKAjP6rq6hmyllHOd2MS9T8jaB0Z+PVnTfo7Y0jmdUeF/fyUZuC/I+EUGRFIQ927pWLYxVj1gMmSLDCFoJ5CYw7WaWnMdTff0nYr+Y3BcQtxAZLB2mXTIlagM9CP+GexkawrdKap5dDGgprG87XwbVOlELR/d/2wHiLHcpm9TRO9o4IZ85UVNLH6H/qk1Kp2vauS1DDNPuV3xsSQxoySIHY7/YJ/z0uoH5CghjFdBNfd+iXcecwxkA7VQVfuW+jcwXGm31NSMzH3oqWo2FcVY3uRIkjoRovBp7wbZwCF7TftCFhMLyfzOgHVe50aXoulTOX3e7j/3exMTSZWE9OgqaxmLKw8V+4ycMB0KcUx69q8I0AoUYkS0ltCp5xqgZmU+Nu6TqQ+0qaXiGGKq9q4YktxUwQoC22i6wStSowU3m1pnbZeUTVI6PdZnFEBd2TTUfEG0SImHOB/xwpxD3etFe4Vmf5vhf0rDHTtBIKAhUXVxUYe6tfQy6HhF6D8cUbWyB6twrbgDZ9XbJtYIy/QoSGi7M8P0QPlWTmeQuo60VHPo2Y3bzprHUedLQLUB6bQrF6UdZ26OD8EkAq9SyLh/QqBWeIM61xE2+mD2lxc/u9/YH8KmQuEre9yrXR58zaYOrCKZCUk8Bz8+BUr1jRqvk+CW1/ALnDpbHfAo/Sn1+Tf7DA5BGudK8scLQxM7bXBGeesaR9bWggxZXbbRqZmJzx5sODhwbh6Qw/nyi/m0Zo51keJPJoWLLaKFKWGmJzrUpHAAzGZO8yaPvi2v993NJJoA2PTg+X9LzMmVY6/OI/eEptBIBL+7wLBRj6ssw1nxrN861jpFK3Tspnb+8w9dnuiO4YZnGqmt9R1D1CfLTnmL3c4R9ENQjsyCfA2ZkZQ55JYHM9cpjcdLTPxE/nhdS8mua8NRlq0C5+aNtvHYyhkDPCLRZy4B5Q7uNMzriZ8MIjpzr9TO+h1vXW6DXOIkFa5gD+8AM0GGM3t8ThPJiePPhEz2JLk3Dcc42/gg1nP129sC7xdt1AbF3MarNEp7CYiRI5LXYrdZ7RzOh3aYRQeMA+ZvKjKCSkw+q3UT3jiBDH15vb9EtZf4/iVgASv+Zf1pYbH6PUTmtVLlj8D0fo3CIigSwWp8TuTRUKL2cxngPYuxomnpMmqhTsDtZwalXNaMqOzkaSQDkkmaTOiPJs4ADxEiYi1cUcYozKLVemE3R5ucV0xmCPsxFldD+gdJqaqpzDnmcyGAA/5AYa53YO6gH9o753TUFu8UtQ6z5Gmkce7SnaSyibrsSa6w79Vkqp7oLILFBv6RI+Uxi9GGJ++y/Dtk9Af0InBcUCuOqB6OBiP5ygyoQ48JXQTJ32ifRtFxkEd+bT9prqE7mLQEoyTAjb+rf0IDtFO2JLez8kMWWczTsnZCZDa2HK0YHWpP3W2KH72cYyju8h1ZEWt0f/RIOKcy6WJfegqF5QyU2C1lyRWwAOXQQ4jpXeTjurEAhBUFuIX/QQa9k4fKfMTzZlfIijL+bxp7iz/V1nJ3ale60zWj8GShP5pI0vi0ZyAmjczTjMUXgMlULzAtAoJd/BehK0mV1ACKnjrqMTDsWzhU= Những dữ kiện mà ta đã biết ban đầu là key, iv, ct, những dữ kiện này đã đủ để ta tìm lại encoded_pt ban đầu. 123456789101112131415161718192021222324252627282930313233def decryption(ct, key, iv): assert len(iv) == 12 block_size = AES.block_size decrypted = bytes() cipher = AES.new(key, AES.MODE_ECB) for n in range(1, (len(ct) // block_size) + 1): num = bytes.fromhex(&quot;{0:08x}&quot;.format(n)) _pt = iv[:8] + num + iv[8:] _ct = cipher.encrypt(_pt) decrypted += xor(ct[(n - 1) * block_size: n * block_size], _ct) return unpad(decrypted, AES.block_size)def data_decoder(text): bin_text = text.decode() decoded_text = [] x = 1 while x &lt; len(bin_text): if x &amp; (x - 1) != 0: decoded_text.append(bin_text[x-1]) x += 1 print(&quot;decoded_bin = &quot;, &quot;&quot;.join(decoded_text)) return bytes.fromhex(hex(int((&quot;&quot;.join(decoded_text)),2))[2:])key = sha256(&quot;128bit_secretkey&quot;.encode()).digest()iv = bytes.fromhex(&quot;1670dc9a0ed463028e1a7d68&quot;)ct = b64decode(&quot;FnDcmg7UYwKOGn1ouDH/nxv55SuZ82NdZzh4IZoMs5q0PXEQu0wTJVF3uT2/IkK4ep2P3tFPyWRp+vSm4TOUhVXOn9EouV4BjaqfCHVM0/i8kPcWE2Ek2wziCCYS66XTrZRkS8T+/kRyqx6dEmUAWqyYKrVrCuGOR1hof1W1ApuX0xYVny+oZZFOH7xzsDKoW6sF7L0zv5R3iGBEo2+cSMRi5alzx2PMcPskGvS0edMFNSm0CpRndYnxb96MSF6cPIsqY8y1QngddCFR9xP7PRCYS3q4GExa844l9DJvAn613RSHNzbWuJaDuEjSil9EOuYxP9+vfCRZ2gKm3SEQqgk9F8a11ag4Yg04WLjgHaXjjU29hH1XJAzgAQ7IAtVQpL/2a0hwc3X9ugzyIZN1cC22eq5W8kb3DZMH2nzVFZBNe9+h/eYpSsy8wVOZt8CkV8JTqFt7hN4rL/zuFUTuDqCUhsCC9ELeJYHCYZgYW7r6M5AigTf4xC8ILlYga8kGPeAGjEsckhygJxLNvBy+YzplDDbygmc9gtymPyaX75EKJ/mLOJFdSq/BlMZi6C+1C5xFsCxcJ14zEH8oqWrUFlRj1wVWMvkCLDLvejP5DO42yN0MP5cHP+Fi4n2KF/cREcpIcLog1bvKBHzAyznV6IAfFHDXc2B2UDf9v6fI9k3USGSb/kBpWVjNYrvI05R50KtnLGLRCYYY349c5MjABYJDFXSvlMQNkJQqjcbts3aM0V3tXgMNyWzurahC/ZrUc3Ex2mAFOULtcWqSHHK4gWq5atZ1tpSGTMhhi5h+66AUK+5xFgBcWEB+g0R/a9MBBgS1lsZdA5gud1K91tk1gbrGV32hdUWjIpKsgDRW2cZfg8nM5wsWVjSTc9o7uoTqsAKkONf2EsEn228ih7XTig5DSkXqgT4/ArX4gaEQzB1px9mNSdMZG7pNfbq6/VNLTDnQdcRlB6uGYp99rOk8HjgYXun7hrB6WWcuTkgi0G54MrjPMpMbmTCuPSnWGG+LnmxkhqR6hd1PK26HpEwt62WD10OlKiJ6LilI/5RsQMDnhf4i+Bel7ZeYltIy9M09rKLa2i7+ZjiigUpuCudJNiv7OjxuQSH2YTiY3tHmcPgnQ5ycWUPdwEhT20ElvB3umlbjiI77FkiswUHjI2jXGn7xmOy46MYFBwt6aju2OxSy+fTyzAxIM4olurcWDOBt/0m1Xc3VQrwphr70eTIgGcx7a4MK9WIZciccGkD7tFE8kM6jvnYRi0Ib5W/xuXZkaJT3KVydI05NOUfUOGasxxOw4M3qGM1/nQifCqATrx4znVylUNixhM4WN26gl9XAQXqQewcdDA7/Hnc8aNmcBuSOgZs4gJjE8S9MyngdnZvUrU6owB5gU0O+1ZPKAjP6rq6hmyllHOd2MS9T8jaB0Z+PVnTfo7Y0jmdUeF/fyUZuC/I+EUGRFIQ927pWLYxVj1gMmSLDCFoJ5CYw7WaWnMdTff0nYr+Y3BcQtxAZLB2mXTIlagM9CP+GexkawrdKap5dDGgprG87XwbVOlELR/d/2wHiLHcpm9TRO9o4IZ85UVNLH6H/qk1Kp2vauS1DDNPuV3xsSQxoySIHY7/YJ/z0uoH5CghjFdBNfd+iXcecwxkA7VQVfuW+jcwXGm31NSMzH3oqWo2FcVY3uRIkjoRovBp7wbZwCF7TftCFhMLyfzOgHVe50aXoulTOX3e7j/3exMTSZWE9OgqaxmLKw8V+4ycMB0KcUx69q8I0AoUYkS0ltCp5xqgZmU+Nu6TqQ+0qaXiGGKq9q4YktxUwQoC22i6wStSowU3m1pnbZeUTVI6PdZnFEBd2TTUfEG0SImHOB/xwpxD3etFe4Vmf5vhf0rDHTtBIKAhUXVxUYe6tfQy6HhF6D8cUbWyB6twrbgDZ9XbJtYIy/QoSGi7M8P0QPlWTmeQuo60VHPo2Y3bzprHUedLQLUB6bQrF6UdZ26OD8EkAq9SyLh/QqBWeIM61xE2+mD2lxc/u9/YH8KmQuEre9yrXR58zaYOrCKZCUk8Bz8+BUr1jRqvk+CW1/ALnDpbHfAo/Sn1+Tf7DA5BGudK8scLQxM7bXBGeesaR9bWggxZXbbRqZmJzx5sODhwbh6Qw/nyi/m0Zo51keJPJoWLLaKFKWGmJzrUpHAAzGZO8yaPvi2v993NJJoA2PTg+X9LzMmVY6/OI/eEptBIBL+7wLBRj6ssw1nxrN861jpFK3Tspnb+8w9dnuiO4YZnGqmt9R1D1CfLTnmL3c4R9ENQjsyCfA2ZkZQ55JYHM9cpjcdLTPxE/nhdS8mua8NRlq0C5+aNtvHYyhkDPCLRZy4B5Q7uNMzriZ8MIjpzr9TO+h1vXW6DXOIkFa5gD+8AM0GGM3t8ThPJiePPhEz2JLk3Dcc42/gg1nP129sC7xdt1AbF3MarNEp7CYiRI5LXYrdZ7RzOh3aYRQeMA+ZvKjKCSkw+q3UT3jiBDH15vb9EtZf4/iVgASv+Zf1pYbH6PUTmtVLlj8D0fo3CIigSwWp8TuTRUKL2cxngPYuxomnpMmqhTsDtZwalXNaMqOzkaSQDkkmaTOiPJs4ADxEiYi1cUcYozKLVemE3R5ucV0xmCPsxFldD+gdJqaqpzDnmcyGAA/5AYa53YO6gH9o753TUFu8UtQ6z5Gmkce7SnaSyibrsSa6w79Vkqp7oLILFBv6RI+Uxi9GGJ++y/Dtk9Af0InBcUCuOqB6OBiP5ygyoQ48JXQTJ32ifRtFxkEd+bT9prqE7mLQEoyTAjb+rf0IDtFO2JLez8kMWWczTsnZCZDa2HK0YHWpP3W2KH72cYyju8h1ZEWt0f/RIOKcy6WJfegqF5QyU2C1lyRWwAOXQQ4jpXeTjurEAhBUFuIX/QQa9k4fKfMTzZlfIijL+bxp7iz/V1nJ3ale60zWj8GShP5pI0vi0ZyAmjczTjMUXgMlULzAtAoJd/BehK0mV1ACKnjrqMTDsWzhU=&quot;.encode()).hex()assert iv.hex() == ct[:24]ct = bytes.fromhex(ct[24:])# print(&quot;iv = &quot;, iv)# print(&quot;ct = &quot;, ct)pt = decryption(ct, key, iv)print(&quot;pt = &quot;, pt) 123pt = b'0011110000001011111101100011011110100011001100111101101110100010101000011010010111001101011111011010010111001101011111011011100011011110111010001011111011101000110100001100101010111110110011001101100011000010110011101111101000010100000101000001010000010101000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101001010101011100110110010100100000010001010111011001100001011100100110100101110011011101000110010100100111011100110010000001101000011001010110110001110000001000000110000101100110011101000110010101110010001000000111011001101001011100110110100101110100011010010110111001100111001000000111010001101000011001010010000001100011011011110110110001101111011100110111001110110010101110101011011010010000001100110011011110111001000100000011010010111011000100000011101000110111100100000011001010110111001100011011100100111100101110000011101000010000001110100011010000110010100100000011100000110110001100001011010010110111001110100011001010111100001110100001000000111010101110011011010010110111001100111001000000111001101100001011011010110010100100000011010110110010101111000001000000110000101101110011001000010000001101001011101100011110100100111011001110110010000110011011001100110010101100011011000100011011001100111011001100011000100110101011000110110010001100101001110000011011000110111001110010110001000110110011001000011101001100101001001110010111000100000010001110110100101110110011001010010000001110100011010000110010100100000011000010111010101110100011010000110010101101110011101000110100101100011011000010111010001101001011011110110111000100000011000110110111101100100011001010010000001100001011100110010000001100110011011000110000101100111001000000110000101100110011101000110010101110101000100000011001010110111001100011011011110110010001101001011011100110011100100000001010000110001001100001011100110110010100110110001101000010100100100000011010010111010000101110'decoded_bin = 111000001011111011000110111010001100110011110110111010001101000011010010111001101011111011010010111001101011111011011100110111101110100010111110111010001101000011001010101111101100110011011000110000101100111011111010000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101001010101011100110110010100100000010001010111011001100001011100100110100101110011011101000110010100100111011100110010000001101000011001010110110001110000001000000110000101100110011101000110010101110010001000000111011001101001011100110110100101110100011010010110111001100111001000000111010001101000011001010010000001100011011011110110110001101111011100110111001101100101011101010110110100100000011001100110111101110010001000000110100101110110001000000111010001101111001000000110010101101110011000110111001001111001011100000111010000100000011101000110100001100101001000000111000001101100011000010110100101101110011101000110010101111000011101000010000001110101011100110110100101101110011001110010000001110011011000010110110101100101001000000110101101100101011110000010000001100001011011100110010000100000011010010111011000111101001001110110011101100100001100110110011001100101011000110110001000110110011001110110011000110001001101010110001101100100011001010011100000110110001101110011100101100010001101100110010000111010011001010010011100101110001000000100011101101001011101100110010100100000011101000110100001100101001000000110000101110101011101000110100001100101011011100111010001101001011000110110000101110100011010010110111101101110001000000110001101101111011001000110010100100000011000010111001100100000011001100110110001100001011001110010000001100001011001100111010001100101011100100010000001100101011011100110001101101111011001000110100101101110011001110010000000101000011000100110000101110011011001010011011000110100001010010010000001101001011101000010111decoded_str = b'8/\\xb1\\xba3=\\xba44\\xb9\\xaf\\xb4\\xb9\\xaf\\xb77\\xba/\\xba42\\xaf\\xb360\\xb3\\xbe\\x85\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05\\x05*\\xb9\\xb2\\x90&quot;\\xbb0\\xb94\\xb9\\xba2\\x93\\xb9\\x9042\\xb68\\x100\\xb3:2\\xb9\\x10;4\\xb9\\xb4\\xba4\\xb73\\x90:42\\x901\\xb7\\xb67\\xb9\\xb9\\xb2\\xba\\xb6\\x9037\\xb9\\x104\\xbb\\x10:7\\x902\\xb71\\xb9&lt;\\xb8:\\x10:42\\x90860\\xb4\\xb7:2\\xbc:\\x10:\\xb9\\xb4\\xb73\\x909\\xb0\\xb6\\xb2\\x905\\xb2\\xbc\\x100\\xb72\\x104\\xbb\\x1e\\x93\\xb3\\xb2\\x19\\xb32\\xb1\\xb1\\x1b3\\xb3\\x18\\x9a\\xb1\\xb22\\x9c\\x1b\\x1b\\x9c\\xb1\\x1b2\\x1d2\\x93\\x97\\x10#\\xb4\\xbb2\\x90:42\\x900\\xba\\xba42\\xb7:4\\xb1\\xb0\\xba4\\xb7\\xb7\\x101\\xb7\\xb22\\x900\\xb9\\x90360\\xb3\\x900\\xb3:2\\xb9\\x102\\xb71\\xb7\\xb24\\xb73\\x90\\x1410\\xb9\\xb2\\x9b\\x1a\\x14\\x904\\xba\\x17' Ở đây mình nhận thấy ở đầu của decoded_bin có mã hex 705f6374667b = p_ctf{, nên mình đã xóa đi một số bit cuối của decoded_bin cho đến khi nhận được đoạn mã đọc được: 12decoded_bin = b'11100000101111101100011011101000110011001111011011101000110100001101001011100110101111101101001011100110101111101101110011011110111010001011111011101000110100001100101010111110110011001101100011000010110011101111101000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100000101000001010000010100101010101110011011001010010000001000101011101100110000101110010011010010111001101110100011001010010011101110011001000000110100001100101011011000111000000100000011000010110011001110100011001010111001000100000011101100110100101110011011010010111010001101001011011100110011100100000011101000110100001100101001000000110001101101111011011000110111101110011011100110110010101110101011011010010000001100110011011110111001000100000011010010111011000100000011101000110111100100000011001010110111001100011011100100111100101110000011101000010000001110100011010000110010100100000011100000110110001100001011010010110111001110100011001010111100001110100001000000111010101110011011010010110111001100111001000000111001101100001011011010110010100100000011010110110010101111000001000000110000101101110011001000010000001101001011101100011110100100111011001110110010000110011011001100110010101100011011000100011011001100111011001100011000100110101011000110110010001100101001110000011011000110111001110010110001000110110011001000011101001100101001001110010111000100000010001110110100101110110011001010010000001110100011010000110010100100000011000010111010101110100011010000110010101101110011101000110100101100011011000010111010001101001011011110110111000100000011000110110111101100100011001010010000001100001011100110010000001100110011011000110000101100111001000000110000101100110011101000110010101110010001000000110010101101110011000110110111101100100011010010110111001100111001000000010100001100010011000010111001101100101001101100011010000101001001000000110100101110100'decoded_str = &quot;p_ctf{this_is_not_the_flag}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nUse Evariste's help after visiting the colosseum for iv to encrypt the plaintext using same kex and iv='gd3fecb6gf15cde8679b6d:e'. Give the authentication code as flag after encoding (base64) it.&quot; Đến đây thì mình chịu :)) Tiếp theo là giải theo hint từ những người đã giải được trong server discord: Sử dụng hamming code, ta phát hiện được 1 error trong quá trình truyền encoded_str: phát hiện và sử lỗi 1 bit kex -&gt; key. Plain đúng là 1&quot;p_ctf{this_is_not_the_flag}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nUse Evariste's help after visiting the colosseum for iv to encrypt the plaintext using same key and iv='gd3fecb6gf15cde8679b6d:e'. Give the authentication code as flag after encoding (base64) it.&quot; Chúng ta cũng nhận thấy rằng IV không phải là 1 đoạn hex dài 12 bytes bình thường, có vẻ như iv này cũng đã được mã hóa, thử với mã Caesa (sử dụng bảng mã ACSII 127 ký tự) thu được đoạn hex: gd3fecb6gf15cde8679b6d:e -&gt; fc2edba5fe04bcd7568a5c9d. Dữ kiện “Evariste’s help after visiting the colosseum” cho ta cái tên Galuois và sử dụng AES-GCM để giải. Cuối cùng là mã hóa và lấy MAC (message authen code) để submit đáp án. 12345678key = sha256(&quot;128bit_secretkey&quot;.encode()).digest()iv = bytes.fromhex(&quot;fc2edba5fe04bcd7568a5c9d&quot;)pt = b&quot;p_ctf{this_is_not_the_flag}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nUse Evariste's help after visiting the colosseum for iv to encrypt the plaintext using same key and iv='gd3fecb6gf15cde8679b6d:e'. Give the authentication code as flag after encoding (base64) it.&quot;cipher = AES.new(key, AES.MODE_GCM, nonce= iv)ct, mac = cipher.encrypt_and_digest(pt) print(b64encode(mac)) 1p_ctf{abJOd6K9aQYOrtl69D79rA==} Compromised (481) Officer Eve suspects Alice and Bob to be performing illegal activities. You have obtained the code that runs on server. Help Eve to break in to their communications.Server access: nc compromised.ctf.pragyan.org 56931Files: script.py script.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/local/bin/pythonfrom Crypto.Util.number import long_to_bytesfrom Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import sha256from random import randrangefrom os import urandomimport sysdef is_too_much_evil(x, y): if y &lt;= 0: return True z = x//y while z&amp;1 == 0: z &gt;&gt;= 1 return z == 1def magic(key): flag = open(&quot;flag.txt&quot;, 'rb').readline() key = sha256(long_to_bytes(key)).digest() iv = urandom(AES.block_size) # AES.block_size = 16 aes = AES.new(key, AES.MODE_CBC, iv) ct = iv + aes.encrypt(pad(flag, AES.block_size)) return ctp = 143631585913210514235039010914091901837885309376633126253342809551771176885137171094877459999188913342142748419620501172236669295062606053914284568348811271223549440680905140640909882790482660545326407684050654315851945053611416821020364550956522567974906505478346737880716863798325607222759444397302795988689g = 65537o = p-1try: eve = int(input('Eve\\'s evil number: '), 16) if is_too_much_evil(o, eve): raise Exceptionexcept: sys.exit(1)alice_secret = randrange(2, o)recv_alice = pow(g, alice_secret, p)print('Received from Alice:', hex(recv_alice)[2:])send_bob = pow(recv_alice, eve, p)print('Sent to Bob:', hex(send_bob)[2:])bob_scret = randrange(2, o)recv_bob = pow(g, bob_scret, p)print('Received from Bob:', hex(recv_bob)[2:])send_alice = pow(recv_bob, eve, p)print('Sent to Alice:', hex(send_alice)[2:])key = pow(send_alice, alice_secret, p)if key != pow(send_bob, bob_scret, p): sys.exit(1)print('Ciphertext:', magic(key).hex()) Bài này nói về sơ đồ trao khóa Diffie–Hellman (Diffie–Hellman key exchange - DHKE), tóm tắt đề như sau: Chúng ta không bị giới hạn số lần thử số eve trên server; Chúng ta biết giá trị p,g,ga,gb,gae,gbep, g, g^a, g^b, g^{ae}, g^{be}p,g,ga,gb,gae,gbe. Nhiệm vụ là tìm giá trị key=gabekey = g^{abe}key=gabe; Đáng lẽ đây là 1 bài toán khó, nhưng ở đây ta có 2 phương án giải quyết: Chọn eve sao cho là một số sao cho ta dễ giải quyết bài toán discrete logarithm problem, tìm a=log( (ge)a )a = log\\left( \\, \\left( g^e \\right)^a \\, \\right)a=log((ge)a), phương án này khó. Chọn eve sao cho gabe≡1 (mod p)g^{abe} \\equiv 1 \\; (\\text{mod } p)gabe≡1(mod p) với xác suất cao, từ đây có thể sử dụng ngay giá trị key=1key = 1key=1. Chúng ta sẽ đi theo phương án 2, bypass hàm check khá đơn giản (thank @bronson113 discord), cơ sở lý thuyết như sau: ord(g)∣o=p−1=16×4... ; ord(ge)=ord(g)GCD(ord(g),e) ord(g)\\mid o=p-1=16\\times4...\\;;\\;ord(g^{e})=\\frac{ord(g)}{GCD\\left(ord(g),e\\right)}ord(g)∣o=p−1=16×4...;ord(ge)=GCD(ord(g),e)ord(g)​ Chọn e=3×o//16e = 3 \\times o // 16e=3×o//16, giá trị z=o//e=5z = o // e = 5z=o//e=5 -&gt; bypass. Lúc này ord(ge)=ord(g)GCD(ord(g),e)=oGCD(o,3×o16)=16 ord(g^{e})=\\frac{ord(g)}{GCD\\left(ord(g),e\\right)}=\\frac{o}{GCD(o,\\frac{3\\times o}{16})}=16ord(ge)=GCD(ord(g),e)ord(g)​=GCD(o,163×o​)o​=16 Chúng ta mong muốn cặp số ngẫu nhiên a,ba, ba,b sao cho 16∣a×b16 \\mid a \\times b16∣a×b. Sau 1 vài lần thử, mình đã thu được flag: 1234567891011121314151617181920212223242526272829from pwn import *from Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESfrom hashlib import sha256r = remote(&quot;compromised.ctf.pragyan.org&quot;, 56931)p = 143631585913210514235039010914091901837885309376633126253342809551771176885137171094877459999188913342142748419620501172236669295062606053914284568348811271223549440680905140640909882790482660545326407684050654315851945053611416821020364550956522567974906505478346737880716863798325607222759444397302795988689g = 65537o = p-1eve = hex((3 * o) // 16)[2:]r.sendlineafter(b'Eve\\'s evil number: ', eve.encode())for _ in range(4): r.recvline().decode().strip('\\n') # ta không quan tâm những giá trị g^a, g^b, g^ae, g^bect = r.recvline().decode().strip('\\n')[12:]print(ct)iv = bytes.fromhex(ct[:32])ct = bytes.fromhex(ct[32:])key = sha256(long_to_bytes(1)).digest()aes = AES.new(key, AES.MODE_CBC, iv)try: pt = aes.decrypt(ct).decode()except: exit(1)else: print(pt) 1p_ctf{7hi5_1s_su86r0up_6on51nem3n7_a774ck_on_DH} Broken Hash (500) Can you extract an image from the two strings with same hashNote: image bytes are encryptedHint: length of strings in key_gen.py is less than the strings given in strings.txt.Files: key_gen.py, strings.txt. key_gen.py123456789101112from base64 import urlsafe_b64encodefrom hashlib import md5from cryptography.fernet import Fernetstr1: hex = &quot;--REDACTED--&quot;str2: hex = &quot;--REDACTED--&quot;hash = md5(bytes.fromhex(str1)).hexdigest() # '99b18a48309cd4d5681ddcd553a27fbf'assert hash == md5(bytes.fromhex(str2)).hexdigest()key = urlsafe_b64encode(hash.encode()) # b'OTliMThhNDgzMDljZDRkNTY4MWRkY2Q1NTNhMjdmYmY='f = Fernet(key) strings.txt124dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2800000000063f0c24262a086dc3e3725d2f4c8c639c4872d8fe25c0502b2cc0d8841d692740e90eeaa9397a5910ef265b08f2463fe996cf1b2b4630e9d183f84b5bf1b6c36c369ac7e69b7c027cd0eafcddcf2fda47f88cacba71be1623b7aef2ccd68b02d7ba4475818684f2ba170bb35d67ba9bcf929dfaca50b70c5f012803b41ae44d3f3d7f898fbf2e1461c063c2bab34387fca00eb9ef452e674d13f7c38dbddd20b0ef5104d7e4a13c8eae8b19b9b28fbf596212be066308a5d94bf1c8702913c30d9024475f03ae898a710beb93d762598220e28c57c2f23db89aff049d46c927d5c48f3902f8ce815b1890fba30992735b6fedbc42bc67516ed34fd901f57f4f606244efda437f8a201ff518553030745ac03bb50597f8f324f7b469346f1057c9ac764a27f0bdbccc0c9215e79fe402b4c7f1356631e462546f16859dc6dfda4d0dfe7167d82ffd8ea27fcd738cfa18b37153c6f878327a9a6048f43588a0c81f2cabd0c9519964322416bd22c4375a4472c34f53cbe0638c9c2ce2ed0511101b1c1d48f173269a1c566add11433e03a9484352c0603092b379d6ec4645b0388c07698dfc0a5e99bbe73e83f19faca64460f212cf799e2e569682d5c225af3e5222df4a1c19d02201b191be79380accad3ada2736097a13c09bebeecab3fb2049d8071b19bc006078527aba76b5750d96f270766b9d74601c441b02cb824430f71222de4491bd265c399d5a7c79519d1c3e73982fda34e22166dfa7420f3fb0e6e1202461ca0ae92a7c1ff2d3bb5977ccf0bd246429711db28d6eaccc333d97cf2ad56eb5a77d6138e2ee9131908485a23bbeee53666c312ebcf533a04efef8dae582396322847b904a6d8740f9154573dd36ad5a167fe6c6db608b33ece02c9860825cb12463cdac15f86ecda71d6207b212a37a7c999f217ddb9d69dd795e112accc61909ba08155ddd50b6eaa27b93de65d57c22d711f333e9f16a5da0c248219fdfa03e1a737da9b6c28def7657b72c4977054b66f788f623121b2c6ff788c609a42f7202bb6985a6b2fa1af682f4cbc0c29ad28e3c977f5bcfc4cc091a06830fcae8f7e74ff8b5841dc319eb19ca6de66245a796ac8504d42ea2cf14751ec9a7f6a0b438055eadac7b012f2f6c9f3adce0769589a8e40e9a1847c9a0ca970b17d26755cd4ccc1926fea4b9fa845e0d8fce1d72e03aa0c6b04cc47ad746155d2c275893ee989c285dd3e41de8db72a82999efe69c3635ab204b1e8f16f37f87cc2c8fbe1aaa950e83f8782dbd9d4dc4527603d0142407585c748011102e3b5261a15b5f678ae05d3d43aa103609b40cdd8ec971fa2bf1fff8fee43c7d098e012c3d3ca1b3f4ca86efb4f5a959f483af7308ad5cb32c0f562a5c614afec2a513473e388d588bf154a977d9ea7e916afdbffabd17b7044ee7c01ab5fa4a99e6969a546bf359307427cea43d028b957c3ed6cfbb1b499a24554242d4a4407e4dcfbfeffcbf50fb3efb25f619c504318b554981704624a18f21adee3fe735932bd5ffb6b2f30f7908ca9c33e2f91ea262b35f2396a2640de32edda28435156bd2085e9b429f0dd496a3641da1b43c52bd983f7a26919f6f8675e2d494bceb3b05479261db44580216ea65a5ecb1faa0b4198ee50be0517d270fd770b426ad7afc7e508d4d8499cc5d679ec1bbee5dfafe3ad42a0525d42e907717961bed967ca78ec9c1964dabe3a6defcd34586051b8c0d15b5a6f5ef1066a36984d3991f24d7b900b48ce6f726a5aed75945851c3641d6814bce1fc7dba4fe9f527eb049a7ddc966a15317d61393482cc39998e0bad402aa3643f7fecb9b007312d178dd9c875ae16117b5ebc687274a5df63ac3c3458f77e673598ec2cdc9721ea9e6849ba5fe2b3920cf2d231fb6a200ed9a5bd7f959ff5c3b9e06e5b43493a2625bbc3baf21545f1939de09a785ba9f512d5c95d8bb8cfbec99a494622c02684ff08e1589e76b09bec850976670eba026b76f689f66eac7df2a4e5e0c70af21ee0ebdb6d5c25df9690a582d16a6cbc3942b156059513bc181bd5561b886e12e1e4f9c1885ad728e62c9c83cb804a777ec632bb2ac6a2544f9f7c9534cf8fa4fa6923e7ec074ca135f171c6bfedf61cea79de0f504a4120756a5db150a19b5844639f804be95cbc7f2af3bbda5cba6b2184ec2839e680b0bd1eae394a54633f0b71f5415869562443de716aafb06e773f205eaef868781ca816fa3472f52c9c18d46a0f9f4089ace5eeec2feb3005149600627cdec2a3a802b66ef4f50d0a99250a44a14407d9392110e38b3c45a870b54dbe21b8ee1d2e58097671cef4d975a43cee3b5804c775cb3bc240230187cd7110fc9f09ecf6e82af32c6cca22e62807838b1d2a0fa4632fe714741cf0de3cfb44d0cee8227089b74bf9f8224e720f793fef5abc227f890cb6f9c3d2bc746592e2bef304ceba1084c5b80bf143dadc238d8d45fa7c9edc914a5e986fc2494962c229e6e63c10c0eb00a99f2adba00933aa6733971f091b3dc047111a30c021803e9e580cad1be2bf051622b3c4503713ffff6c38bb59a79329990e7669ad60bf97282d6c1989291a8eec25b5cd7cd7a4c66ed9264136e55eec447668b495ac4641f081d4401b5fbf5a19b91f160561ca80a761ac560e9b6fb0504b3ec250bdf741cf877fa174efcd72a25c0954a606b511e0948265279dabac005a09133f7d86162d52b84df10a20b50e0d84bbb461de7c147d09de78f425b921d9be22d328d7cd49b9337fb8572fefab66a80cb780bc0f97408ad58ddc92458aa3abebf04d7d0837ab23b1e7a47cbfe3a14151cacc828e575933792fd8f2f6835b5154d996b60319e7538c6a31fdacc7ab94d17bae062d9f5e90c4572911b1578268c3d13dbc21dd4cadfd42c5cc4b05fac2f88ef8a79ca1d323654f00a254d2e56c0dc361e5874dc2437c8dc6c3af3fc345373118d132aef16c77a78a715cab96d6fa666e816f3f6e0c5fe4df27056332e9ba80d5051fee49c985e03ca44a7dc99354fe5744c1451b8c4caa83939f55489372889faab80abdd578cb914b4ba772dd3c57fc90825eea1c5fb0f8532c12ed917853297fbed8f6c884ca778c28ec244e1d62833da477378f5d3f6a00b68c8a75dc97e66742ac5800fc43e53eabbe8268634986ff3d9a7364bc3d411a332ba9acb7358b495f4050017ab44475fe740a383c587703b238fcecba354328e61b2ff00005959ce823aba02d46cee338be23be58c75bf078a12c96e9190fd88840b0e0539ef2252e85eeab37f484ba5199532b47f9eaae837ce81c16b744dca62befffcf0242bd96ffc163927cb3e6bb041a02ad46d4c889a90b95e7533c187835b587b50130e307eea0b7e28ddcf54f203183323e8c5f1bd94468e5b6d716dc60a409eee21e2ac62857cb87d04568deaa10eb64bcaf4b211abe1abcaace0654e75acd9700c2db210419dcf8866acf45440951abbf58b54c5768cf97cdb03ead9aef8955e426ece0d819665f97f484f465bd795e5cdae5a2714297a9e865a7f534b533d4342a4c5494ef062651d492a78c2011cb8391937ad88d524f25216c75c6613e2246007b8cad6c95e1b406b2ceec2c88a9ab268f84e0420c219ad142088c0c4ac15e3183d9e48e2f2bd9d0bc2a7491b9cb40e6916020e0c1b6a12459e662e8371455beee8b0ccdee918ca199b04546ad23bf6699132d9f46e80d88abb04f80d828d39883051d7b8c3ef4f2c5e396b076902f1adb0b1058267df23fc22d7dd313d4f9b44d2432385d749453fa070ddebf474df2b917211d78c5c28f68ffd9a824333649be301a0a6c2e06f8301f29d461b84e3bae9ae9d6c06e1dfb2545e46e96ae6d70c5b0c00a3c5b93b08ea13e85ffb649c57e93360e37fb867215d009d8318470c02b5b90dd60dd45f30f43541014b6d9e7f9889b1856d11aa9e5f25fc065095e1993fa402be63655196370f8c0732058fb540ddc3dc08a0060339af777395a47b4988be89bd47372ff648c391409119efcb46987f5e7da68950e72f82750e98f2dd1ce708cfd789b4ee0ea7619ed916a094c5a8f8d7afc139b90dcd94ae0157dc85641d858b559009c9c38ccc237813d3b8491b331f7c617226753b3db0f55e2360718378ff4da4a2e47780362d541a0d9a002384c4b14c27f94bc4a30fb2798273a62da00db3260e16d8c000e14c7cb9bd3244f2e1d6774a9bd49a64a78c90372277d2e0e58ee755f1cb658c76ea45d6d801796de2a4705492ee8dc11d6ca830e297f6092f585de215024b3ec0b566f50c35e54476ca80b052cb8f67da904ce663e9de10848bc48ff6ccb4ec74f08d40cfeca9afbaf7f96b77dbca97a8d860fc6a360336121e338290073920fe6585473f10e468302c4121e5c269b0823aea9ff37a4b2a5f5e8845cd606d4d199a405108b24c373c814cfe7c1334719a69f9ec17034179ca4ab654ade657a40841174ca1d4add662704c1f66973858675033f6bdbd1b147ba12aca2b642d8e7ba40035d519d3179b82036a76715fd152c7fe3be4fc6da853826f3f77c309c0d5cb5c90ef7029df504a7a9224f00a352ceb02e248cf4f1e8e6e07b8c8152f5fa7de7806caeb9ccf40835bee6d240c032c2d0e8543d4c17999959435a0d1f6297bc9a9936bb75de5ee118ca6e2c4a5e759c16ed8ad16c422e16b91394e561acc450ce58e47ed55b77ca4b6424304d90cd3020ec7be541a7f0c30116a3acde1c3be5a7842264ea2975a076148372f73a4ca4a35d48a441d968204d55ae6cad03727e47b48179584e3e8eacfedbe51dd5956b53ade7a4c2ffe3db3b32976840c4c8687d26ebc201e40e55bae40f0d8a28d282b9ed110542a052cc7e89489244900f0e4167521a5faddaffb6500fc8c800e6bb95299c56a3c6d65d34f38b7d14aa547154bdaa8231c0a524ca82dbe37d73fa4dee12066e75cda7b36f2bba04d48d0c2fe1c83fc3b6b792eed270352e1431498950d036277c5e60b272758d15bc30e4f8bd236f7d40b9f4be13d400a76f5256a736a2127249f9c7d0b189b7988b1608f993ad2f836faa3b90bd0c1e22dab5a9ade2148ace1360a98befb96f9e1d31ec30eae6b2145b5cdbb7e2ea6ff1e2e6160c5bd56718bc77d937faec02801740ad4f7b2919d9ab303922089d5658a9ca8034f5ec1684a952b302b9562e0673acd9f1a6e11492cca28bbc8eae0263febaecc07d57dbdb1fec263d86e96372899094c19071b6d4fc9db01742230f3441776b00fbd4158cd1fb92f7e1090de791bf65628281b9ea113409e13d07bcfa1838a12965ea16955b5c5ab9d32879b9cf89b094a46eeb23a9bbe13c3660c1f967ddc56642a065279ef3adf5f3e886f46bf73819272857f9d1b424d1a40d7794b7b31abf20d4315e92b469961bc6ebeb53b86e4c0f9eb7499ca4ee2afbba78dbf99fb3783d5bc8867080cfd6e48961deaaed2119033955ab619da0a349261b3c671d0ae27dd6699948df6d421065d8b1248eae403d54a0bacfd02eb996af5bda97d37b40e8aec4ad8c37a9933bbfcba0f66d04756bb278bfc7670d1396dfddc33d0da78da5dd01c7f5d643c473b08e20605b06278d55a59106dc5b9290b59f1a9f4e6d2d0ea0232baa47c68e43308771bf4902e0ea521ca320820ba4442ae393ae4ebbfbc46c493cd95ea8850c9b8ad995a8dcfd1fe46f91364cd853c7727a9978aa7cefa4c6dc2e73afac7881a60268e419b9c3833b2b66267d6273d1011c11c5e9309c607ef7669552ebd73d6395ec7d05cea071c9022a5610f9beb4a3b569a6ab01c58a68e50e8285896359b9849518367041b8b6fb95eb9f2db641d88f7ac494100b05ff0438ce629115d21eb84a6e75a6a3eefca30471b02927b1357cc54c3e1b24b3ac188761dfb23cc8e0a3ce682b11a85fec3fe485d8f364bc816ed61e71dc8d33da33a9451bc86748c79c216842e46333ce45e73b06dc05a40e47f33a7f78b3caae85e65fc536b6269ceca76761880c0c97e4b6664e8f606607a31626b282499365fc6d6ef6dc524972cd7155c0730a0a363efb04456fccc20e8f29c4bfb9214944d52c06a1246c3c008aadaa21ee07f02847e9ba351ce83c80e5a8bf44afe0d70d4411c2b9e92eaa43ceaf1fe3e492bf8a2e6775f10b63b9734beafc4a7991c78448ea435ce1d135c7cdaf0a6adf16ab94b6e6cdea82581932ccdebc46075dcb3f695329a22ea4f4ec59f0638e6580975caf5d69840d3454a742a56883a231cc199b0da16a231856ab54f250fa5db984543b0e50de0af69f43208db285899b5a65563302bb023c9677c4d205c716df5099108a4d511b914cbe662ea823bdde03588bc3f7315a66eeade6365f2d0827f70f7aa54861726a542f5662c482843f90a708960f58208eeb10bbc2d6eafe3cfe46c74d6b62292d53a6b7d82dbdc147c3819ad2ddd288194418d02a61c6f8fc94118b4ff6258ff66a7361105e311213f3b18205d62178feba28bd26b299c20f2d68317704409baf6bc9aa7dd66c8b83b8c9a05e6e65c72560c104bbfd7d615fcb61d2c9c02f316256de024571a0ad4cb4c71f230f4115b2be304200dfe9ec0d6fb2ada5acda7eea74b8cf1477a935e2860843fdea58491fe50d5e6a793d5e597f2d306ac3f08f1da7a534eeba7b734dc7bf9572b44b1b8b96fd5bfc8dfc544d7ac52e31e3b50aa59339a0ababbf93da0b124c4117fd69fbd0f7a7e28a8c46c73fe212380e54552f5c2872a2bf3a6a1a9f3a5f10dff252331a25d08a74bc7de564af2e109adad5961df62bfbb502945c960cf96a2dab043f1cf4126cd7fa64e260f39ff0dd120959e105055605e1acaa4d89b64e051a06d5093807b5d316820c9f08cca102c64765cdef4aae4f45aa3279cc3539795b57571b369b600bc91805d38778ea78e2da734323a5c35d5803ab788a5ef277490f29a633f4e7d4efeaa9764b99169b5ca4c7f0d533ef5e1a8cc6f3e1bc38d8b0b9a1d4b5087d68312b084e0fb82f57e77275603881f53c3c69f6be61a2b742cd12e8652ac7fefd43db35731d8dddac28f6c78bdcf4340f19cf867a5eb2bd0079951fac68d9a541739e4d89e9e707695ebc303dc217d5829f9bed63ae753d9fe65d44bb3a04c1281d711d64941105063286fe8fa892780a562faf7bdcd10c0b69ea6f0093d5f19feb4f46a977674ddd3c137eb2ed6ca824f0cdc8e4466690ec812378300e73528bbcd4a13e1bb6759546721992425a4b8af751bb1935ccf1f4d318e412224aa1b9562a729ea120f1ca92ce0062b4d6f75a64d0d2dfab2ce77d05fc8ea7b73f49536527fbc06ca0db029f54698d820fc29c3d6a13201a0ddf9098820519eff32b6d160db1d60b039f4176d822d6e4eb13226969fa4a35a1a46cdc5915c4f2afade7da68451b7edc6f20f21978dcb16cbc458051cd225bbf4077d171d6c2d47935c1377e84fa9a19b0fefa7f04015f3fb8d4e95e81ed7d8aae0ed46d1d6dbb589991daa751b52e24b332be20eb8e5274b3b8c69755ac64e56f8710b6bb84b1437c6e6458f8f3eb58373c3df41f84ce563fa257da81e5b7f14003c9905fd5113aba446f75c8cf2d1b0966789a2ba746f911e9a1cc4ae427916d47eadedd95d103b5f650906c911ec40b1bf2aa6b4d767d520c04d461a489b70c18b80c82f7a57409c0085a4be233aa3a9a9f3839e18b2f64d32fc5b39597e66db4b1484dee84da0dd13f4e10d76949df633d0c3f2798ad2af6bd78e8959ad0f17ce658af607e6890883c6cdd4d6d8db2255deb4b71883c36164fbc1f0d9528f494a586d47e8152929b353ea78449267030e95869aeec27c70ee5178e7b1645f373f6763a514176ad1c1474db0d0797b730e352ea83db60e2c6472e5982175ca780fb0505a95a3adb853ae5c1377a015a09572fe73896c8edb8cb59596e4175d2699619ebf8fb075f4ee3211622f51afd110886902cb1493fb2aee0fd5e9591fac6bc75d1e01d5241237924e0d843e222f0805bb6cb25780e659b8ea7f5446aba027236fec34a492e00084c95fa0478ccace3691c2ac0d99e733eb6b0ffbc7cf12d072644b4b6512eba5157650f4e7007c9b762e0ab98cc4125d9bfcfc61783b6f5656735694b0a4aa4e3c3f6cb9cd8dfa8e67af2821a9a75d36891fc1967cdde556a35c25e0859d41c223586b4ce4de9d174bdab40cf1d2b328a28d2e1d47710b505c2c2f2b848c4936f4429ebf108b2056aa894bccc29649da708bb9e8667bcb4f8076f8f9e53829c91f2ce4f63f5e10f79abcf4276a9534c83a1e8ead7da7f8a0b41cc809905f65691061d207867c4a49ef3c1429ada4cbd3910c2484b563cc04aeac799926f3f64f5e10de6f743ef8f3629314f3d9069ed447541ead497a9b40f41acd4f55c94b6e804521349444b353b16b3f4039fe3c5c85df7928a0d1da63702c5f293fac7dcaa1c5d7329f1a7258bb0ab27208b395ac0ae4b183731e540fb7c18f8532a084daebd0c798e5ab5363227dfc8b3190682c4c933c18fdfbaa622388dbf1e388f13099f08ed73f45e420a9604219a861f78212e1f5d50a6729956d18aa1011b6aa1f5b9fef3b68804419928166c6d859cd84d2533c64b9f489ae7f88712d85282705a382c8176e21af7d8925b49e12e7272d52e9a138a8639aaa803b571573b39609317a29c2882857f7fcaf369a2fe48d602dc8216763d929eb6ce9614f53d821c70b2a7fca89c52bc96a4e384087a7dc2d8214b939852c79fe85bcf4cba76df4bb53013f2774da289801aea53d9b12700f740be1f62e0290e60d7f8f8e4661f9de7059ad6dd2bd3c36aacef5dba3b733a3f65c771142a21ade2902e8b0b0e55fbba0c2ad7c2bf792542d7ff5ea107a275950c81692df957412f6b4c4cbad89b00dd903e5458faf08f3c4070c3f5912eb66230475b74ec9d191e18539ac5cd62c55b900a290208477418ed6a89c640ddf66ebde7c8baa001d4ebcf0822dbdddc46d556b69dafb170dfaecb0318bfcdf0bee66d47451deed636eced72db0486e7fee97c25ab50a542e33a070e2513995269372417b02020d6ded8646a0bc9c36bcbc570f4c2c01d4af55bfde1e7a20f2337a2bbf22e3b20de02f874a8180a894eac8d1297ba80211a6555c5d5e880ea5c4f02fb1493950b08d2419e0f060ea4dd64c914f79f011a763cbc422612bc19a69e26c145bab55a08894d4e8ea44a203ae60935a2f056efa8487d3924ece0e35bb449c956680d197b53f14b290c2d840e033461d5414671983ded386a3093f2dc659ea3b7e85fb3df76beefb3db4c7645f3d8eb819496803b9a48aadca4d88a1e3556647bc685bbaf558e60234e21e4c8efb9337746903cdb62c7d5454d5e07c269a60c23fe33fd800e939fb94cc9cd1a5c3765c08b0950a112515b158b95c61a36fd7eb7a4976ed79acfcf446befe839f2f79dad5355e7c137b436e2082282925954c54a1f56b43f0668cde18922d20b26d178b38e1909e94cf7db7e31e1cf06c3ff180ce549a2f4572bde1792d0b696a9d9c0ef7b7350255cfc5f53b5a997a08a822094696fdb9f72e4acd892982e5cb36f427471c2c76b7589a3e82d5c38b7fa57d3fa6b4e858de7092f48a76120570a7b02f28ba766a054455c2664c2161390c0a3d632226fcf9771474cd2dfb805905b5a5c17b8d7db6d92675c78415d2f55100e501d849d8d92247a9845d14909f49119152ecff64518c69c41eda50a7e87f977e2d03d3a323647c3fc03eb2e5454685e8f99fa63f851719b8fa2881f3ceb257b813f449bd7283e1b98478b3a213a593d300414625415f19b09f962e2264c0f1e8986f0178f7ea0098d87faf95a427ad57326d4b2ec98d32375b7d81edb5060900ba5da15c3fc3ebe504d8a023e5f904ae7b1e7115bf9f3da3d334394e650f18eabe5ed7e8e325f60097e227b2a6543a09def2e762016076eaca4acdcda7191a6f7d5a4f1aa390f4ed403823c2bd6b645bbf22c252c1cb7696965784329c19307fec170e38bec871b6718a6444cd7eaa23e0af1d3006e5bb37e1cab38792cf5e00003fdb860d68b41e17711182583111e115f69071dbe79b5b4081ac501ad69064d77391767ffa5a798ffd4841c4a967ee001a91939daf332e5d49044d2b17271617d95065018d684f0192dc2f805c3a644f466ce8dacb881c7413e99d809e3786265886a265a9b9a0d72dfcb4fcd65e4a5f866ea4ad74a96eab5c9cacd6ac0052e6b59d3c954e760acfb280982b7476b96cf018bcc033fdc113b8f84632593b1c09cdb1eb56bd90314f0ffdf562bfc6170fffb732c8e8ed862d99c54bfe2666216361516f46f8e22598e47be59e61716a80cc953a517516f10a5511f27511625215707588c78ffc259e4599e383932a48ca177b20c4d8c55d8d9336b77c832d07e11e373cef020837dfe3f687cbb83dac529d86114e727a5d9a587aa520334d6590e6f576f64382dfb9dd398ec33833405d1fec82f9e4b3bc73c19d302fb60434cf7f77b26c23d5ce9f503f129784f63546ebea9cae7e76de3b6788ac15f9fbabd0e8901f29124da858ade5c29d6a2938d4620668fd90163049af59fd627c32aa9d432d2b3073352270632f5436c267380a54bed9abe8e894f3dcb20a11cf07de336ad2ca347cb3262ebef3daebaf6822ccf002eb22647d7b591f233f745672facda6a575f6139c0383f1dc298c9927e892ae534a041412879098e0f6c35c1cbcfcb893a8f75ed272d2ac8091caa54488ae5d4541c60739d6cee6b91c6debe0605d402846f0aa69372315288de4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2800000000063f0c24262a086dc3e3725d2f4c8c639c4872d8fe25c0502b2cc0d8841d692740e90eeaa9397a5910ef265b08f2463fe996cf1b2b4630e9d183f84b5bf1b6c36c369ac7e69b7c027cd0eafcddcf2fda47f88cacba71be1623b7aef2ccd68b02d7ba4475818684f2ba170bb35d67ba9bcf929dfaca50b70c5f012803b41ae44d3f3d7f898fbf2e1461c063c2bab34387fca00eb9ef452e674d13f7c38dbddd20b0ef5104d7e4a13c8eae8b19b9b28fbf596212be066308a5d94bf1c8702913c30d9024475f03ae898a710beb93d762598220e28c57c2f23db89aff049d46c927d5c48f3902f8ce815b1890fba30992735b6fedbc42bc67516ed34fd901f57f4f606244efda437f8a201ff518553030745ac03bb50597f8f324f7b469346f1057c9ac764a27f0bdbccc0c9215e79fe402b4c7f1356631e462546f16859dc6dfda4d0dfe7167d82ffd8ea27fcd738cfa18b37153c6f878327a9a6048f43588a0c81f2cabd0c9519964322416bd22c4375a4472c34f53cbe0638c9c2ce2ed0511101b1c1d48f173269a1c566add11433e03a9484352c0603092b379d6ec4645b0388c07698dfc0a5e99bbe73e83f19faca64460f212cf799e2e569682d5c225af3e5222df4a1c19d02201b191be79380accad3ada2736097a13c09bebeecab3fb2049d8071b19bc006078527aba76b5750d96f270766b9d74601c441b02cb824430f71222de4491bd265c399d5a7c79519d1c3e73982fda34e22166dfa7420f3fb0e6e1202461ca0ae92a7c1ff2d3bb5977ccf0bd246429711db28d6eaccc333d97cf2ad56eb5a77d6138e2ee9131908485a23bbeee53666c312ebcf533a04efef8dae582396322847b904a6d8740f9154573dd36ad5a167fe6c6db608b33ece02c9860825cb12463cdac15f86ecda71d6207b212a37a7c999f217ddb9d69dd795e112accc61909ba08155ddd50b6eaa27b93de65d57c22d711f333e9f16a5da0c248219fdfa03e1a737da9b6c28def7657b72c4977054b66f788f623121b2c6ff788c609a42f7202bb6985a6b2fa1af682f4cbc0c29ad28e3c977f5bcfc4cc091a06830fcae8f7e74ff8b5841dc319eb19ca6de66245a796ac8504d42ea2cf14751ec9a7f6a0b438055eadac7b012f2f6c9f3adce0769589a8e40e9a1847c9a0ca970b17d26755cd4ccc1926fea4b9fa845e0d8fce1d72e03aa0c6b04cc47ad746155d2c275893ee989c285dd3e41de8db72a82999efe69c3635ab204b1e8f16f37f87cc2c8fbe1aaa950e83f8782dbd9d4dc4527603d0142407585c748011102e3b5261a15b5f678ae05d3d43aa103609b40cdd8ec971fa2bf1fff8fee43c7d098e012c3d3ca1b3f4ca86efb4f5a959f483af7308ad5cb32c0f562a5c614afec2a513473e388d588bf154a977d9ea7e916afdbffabd17b7044ee7c01ab5fa4a99e6969a546bf359307427cea43d028b957c3ed6cfbb1b499a24554242d4a4407e4dcfbfeffcbf50fb3efb25f619c504318b554981704624a18f21adee3fe735932bd5ffb6b2f30f7908ca9c33e2f91ea262b35f2396a2640de32edda28435156bd2085e9b429f0dd496a3641da1b43c52bd983f7a26919f6f8675e2d494bceb3b05479261db44580216ea65a5ecb1faa0b4198ee50be0517d270fd770b426ad7afc7e508d4d8499cc5d679ec1bbee5dfafe3ad42a0525d42e907717961bed967ca78ec9c1964dabe3a6defcd34586051b8c0d15b5a6f5ef1066a36984d3991f24d7b900b48ce6f726a5aed75945851c3641d6814bce1fc7dba4fe9f527eb049a7ddc966a15317d61393482cc39998e0bad402aa3643f7fecb9b007312d178dd9c875ae16117b5ebc687274a5df63ac3c3458f77e673598ec2cdc9721ea9e6849ba5fe2b3920cf2d231fb6a200ed9a5bd7f959ff5c3b9e06e5b43493a2625bbc3baf21545f1939de09a785ba9f512d5c95d8bb8cfbec99a494622c02684ff08e1589e76b09bec850976670eba026b76f689f66eac7df2a4e5e0c70af21ee0ebdb6d5c25df9690a582d16a6cbc3942b156059513bc181bd5561b886e12e1e4f9c1885ad728e62c9c83cb804a777ec632bb2ac6a2544f9f7c9534cf8fa4fa6923e7ec074ca135f171c6bfedf61cea79de0f504a4120756a5db150a19b5844639f804be95cbc7f2af3bbda5cba6b2184ec2839e680b0bd1eae394a54633f0b71f5415869562443de716aafb06e773f205eaef868781ca816fa3472f52c9c18d46a0f9f4089ace5eeec2feb3005149600627cdec2a3a802b66ef4f50d0a99250a44a14407d9392110e38b3c45a870b54dbe21b8ee1d2e58097671cef4d975a43cee3b5804c775cb3bc240230187cd7110fc9f09ecf6e82af32c6cca22e62807838b1d2a0fa4632fe714741cf0de3cfb44d0cee8227089b74bf9f8224e720f793fef5abc227f890cb6f9c3d2bc746592e2bef304ceba1084c5b80bf143dadc238d8d45fa7c9edc914a5e986fc2494962c229e6e63c10c0eb00a99f2adba00933aa6733971f091b3dc047111a30c021803e9e580cad1be2bf051622b3c4503713ffff6c38bb59a79329990e7669ad60bf97282d6c1989291a8eec25b5cd7cd7a4c66ed9264136e55eec447668b495ac4641f081d4401b5fbf5a19b91f160561ca80a761ac560e9b6fb0504b3ec250bdf741cf877fa174efcd72a25c0954a606b511e0948265279dabac005a09133f7d86162d52b84df10a20b50e0d84bbb461de7c147d09de78f425b921d9be22d328d7cd49b9337fb8572fefab66a80cb780bc0f97408ad58ddc92458aa3abebf04d7d0837ab23b1e7a47cbfe3a14151cacc828e575933792fd8f2f6835b5154d996b60319e7538c6a31fdacc7ab94d17bae062d9f5e90c4572911b1578268c3d13dbc21dd4cadfd42c5cc4b05fac2f88ef8a79ca1d323654f00a254d2e56c0dc361e5874dc2437c8dc6c3af3fc345373118d132aef16c77a78a715cab96d6fa666e816f3f6e0c5fe4df27056332e9ba80d5051fee49c985e03ca44a7dc99354fe5744c1451b8c4caa83939f55489372889faab80abdd578cb914b4ba772dd3c57fc90825eea1c5fb0f8532c12ed917853297fbed8f6c884ca778c28ec244e1d62833da477378f5d3f6a00b68c8a75dc97e66742ac5800fc43e53eabbe8268634986ff3d9a7364bc3d411a332ba9acb7358b495f4050017ab44475fe740a383c587703b238fcecba354328e61b2ff00005959ce823aba02d46cee338be23be58c75bf078a12c96e9190fd88840b0e0539ef2252e85eeab37f484ba5199532b47f9eaae837ce81c16b744dca62befffcf0242bd96ffc163927cb3e6bb041a02ad46d4c889a90b95e7533c187835b587b50130e307eea0b7e28ddcf54f203183323e8c5f1bd94468e5b6d716dc60a409eee21e2ac62857cb87d04568deaa10eb64bcaf4b211abe1abcaace0654e75acd9700c2db210419dcf8866acf45440951abbf58b54c5768cf97cdb03ead9aef8955e426ece0d819665f97f484f465bd795e5cdae5a2714297a9e865a7f534b533d4342a4c5494ef062651d492a78c2011cb8391937ad88d524f25216c75c6613e2246007b8cad6c95e1b406b2ceec2c88a9ab268f84e0420c219ad142088c0c4ac15e3183d9e48e2f2bd9d0bc2a7491b9cb40e6916020e0c1b6a12459e662e8371455beee8b0ccdee918ca199b04546ad23bf6699132d9f46e80d88abb04f80d828d39883051d7b8c3ef4f2c5e396b076902f1adb0b1058267df23fc22d7dd313d4f9b44d2432385d749453fa070ddebf474df2b917211d78c5c28f68ffd9a824333649be301a0a6c2e06f8301f29d461b84e3bae9ae9d6c06e1dfb2545e46e96ae6d70c5b0c00a3c5b93b08ea13e85ffb649c57e93360e37fb867215d009d8318470c02b5b90dd60dd45f30f43541014b6d9e7f9889b1856d11aa9e5f25fc065095e1993fa402be63655196370f8c0732058fb540ddc3dc08a0060339af777395a47b4988be89bd47372ff648c391409119efcb46987f5e7da68950e72f82750e98f2dd1ce708cfd789b4ee0ea7619ed916a094c5a8f8d7afc139b90dcd94ae0157dc85641d858b559009c9c38ccc237813d3b8491b331f7c617226753b3db0f55e2360718378ff4da4a2e47780362d541a0d9a002384c4b14c27f94bc4a30fb2798273a62da00db3260e16d8c000e14c7cb9bd3244f2e1d6774a9bd49a64a78c90372277d2e0e58ee755f1cb658c76ea45d6d801796de2a4705492ee8dc11d6ca830e297f6092f585de215024b3ec0b566f50c35e54476ca80b052cb8f67da904ce663e9de10848bc48ff6ccb4ec74f08d40cfeca9afbaf7f96b77dbca97a8d860fc6a360336121e338290073920fe6585473f10e468302c4121e5c269b0823aea9ff37a4b2a5f5e8845cd606d4d199a405108b24c373c814cfe7c1334719a69f9ec17034179ca4ab654ade657a40841174ca1d4add662704c1f66973858675033f6bdbd1b147ba12aca2b642d8e7ba40035d519d3179b82036a76715fd152c7fe3be4fc6da853826f3f77c309c0d5cb5c90ef7029df504a7a9224f00a352ceb02e248cf4f1e8e6e07b8c8152f5fa7de7806caeb9ccf40835bee6d240c032c2d0e8543d4c17999959435a0d1f6297bc9a9936bb75de5ee118ca6e2c4a5e759c16ed8ad16c422e16b91394e561acc450ce58e47ed55b77ca4b6424304d90cd3020ec7be541a7f0c30116a3acde1c3be5a7842264ea2975a076148372f73a4ca4a35d48a441d968204d55ae6cad03727e47b48179584e3e8eacfedbe51dd5956b53ade7a4c2ffe3db3b32976840c4c8687d26ebc201e40e55bae40f0d8a28d282b9ed110542a052cc7e89489244900f0e4167521a5faddaffb6500fc8c800e6bb95299c56a3c6d65d34f38b7d14aa547154bdaa8231c0a524ca82dbe37d73fa4dee12066e75cda7b36f2bba04d48d0c2fe1c83fc3b6b792eed270352e1431498950d036277c5e60b272758d15bc30e4f8bd236f7d40b9f4be13d400a76f5256a736a2127249f9c7d0b189b7988b1608f993ad2f836faa3b90bd0c1e22dab5a9ade2148ace1360a98befb96f9e1d31ec30eae6b2145b5cdbb7e2ea6ff1e2e6160c5bd56718bc77d937faec02801740ad4f7b2919d9ab303922089d5658a9ca8034f5ec1684a952b302b9562e0673acd9f1a6e11492cca28bbc8eae0263febaecc07d57dbdb1fec263d86e96372899094c19071b6d4fc9db01742230f3441776b00fbd4158cd1fb92f7e1090de791bf65628281b9ea113409e13d07bcfa1838a12965ea16955b5c5ab9d32879b9cf89b094a46eeb23a9bbe13c3660c1f967ddc56642a065279ef3adf5f3e886f46bf73819272857f9d1b424d1a40d7794b7b31abf20d4315e92b469961bc6ebeb53b86e4c0f9eb7499ca4ee2afbba78dbf99fb3783d5bc8867080cfd6e48961deaaed2119033955ab619da0a349261b3c671d0ae27dd6699948df6d421065d8b1248eae403d54a0bacfd02eb996af5bda97d37b40e8aec4ad8c37a9933bbfcba0f66d04756bb278bfc7670d1396dfddc33d0da78da5dd01c7f5d643c473b08e20605b06278d55a59106dc5b9290b59f1a9f4e6d2d0ea0232baa47c68e43308771bf4902e0ea521ca320820ba4442ae393ae4ebbfbc46c493cd95ea8850c9b8ad995a8dcfd1fe46f91364cd853c7727a9978aa7cefa4c6dc2e73afac7881a60268e419b9c3833b2b66267d6273d1011c11c5e9309c607ef7669552ebd73d6395ec7d05cea071c9022a5610f9beb4a3b569a6ab01c58a68e50e8285896359b9849518367041b8b6fb95eb9f2db641d88f7ac494100b05ff0438ce629115d21eb84a6e75a6a3eefca30471b02927b1357cc54c3e1b24b3ac188761dfb23cc8e0a3ce682b11a85fec3fe485d8f364bc816ed61e71dc8d33da33a9451bc86748c79c216842e46333ce45e73b06dc05a40e47f33a7f78b3caae85e65fc536b6269ceca76761880c0c97e4b6664e8f606607a31626b282499365fc6d6ef6dc524972cd7155c0730a0a363efb04456fccc20e8f29c4bfb9214944d52c06a1246c3c008aadaa21ee07f02847e9ba351ce83c80e5a8bf44afe0d70d4411c2b9e92eaa43ceaf1fe3e492bf8a2e6775f10b63b9734beafc4a7991c78448ea435ce1d135c7cdaf0a6adf16ab94b6e6cdea82581932ccdebc46075dcb3f695329a22ea4f4ec59f0638e6580975caf5d69840d3454a742a56883a231cc199b0da16a231856ab54f250fa5db984543b0e50de0af69f43208db285899b5a65563302bb023c9677c4d205c716df5099108a4d511b914cbe662ea823bdde03588bc3f7315a66eeade6365f2d0827f70f7aa54861726a542f5662c482843f90a708960f58208eeb10bbc2d6eafe3cfe46c74d6b62292d53a6b7d82dbdc147c3819ad2ddd288194418d02a61c6f8fc94118b4ff6258ff66a7361105e311213f3b18205d62178feba28bd26b299c20f2d68317704409baf6bc9aa7dd66c8b83b8c9a05e6e65c72560c104bbfd7d615fcb61d2c9c02f316256de024571a0ad4cb4c71f230f4115b2be304200dfe9ec0d6fb2ada5acda7eea74b8cf1477a935e2860843fdea58491fe50d5e6a793d5e597f2d306ac3f08f1da7a534eeba7b734dc7bf9572b44b1b8b96fd5bfc8dfc544d7ac52e31e3b50aa59339a0ababbf93da0b124c4117fd69fbd0f7a7e28a8c46c73fe212380e54552f5c2872a2bf3a6a1a9f3a5f10dff252331a25d08a74bc7de564af2e109adad5961df62bfbb502945c960cf96a2dab043f1cf4126cd7fa64e260f39ff0dd120959e105055605e1acaa4d89b64e051a06d5093807b5d316820c9f08cca102c64765cdef4aae4f45aa3279cc3539795b57571b369b600bc91805d38778ea78e2da734323a5c35d5803ab788a5ef277490f29a633f4e7d4efeaa9764b99169b5ca4c7f0d533ef5e1a8cc6f3e1bc38d8b0b9a1d4b5087d68312b084e0fb82f57e77275603881f53c3c69f6be61a2b742cd12e8652ac7fefd43db35731d8dddac28f6c78bdcf4340f19cf867a5eb2bd0079951fac68d9a541739e4d89e9e707695ebc303dc217d5829f9bed63ae753d9fe65d44bb3a04c1281d711d64941105063286fe8fa892780a562faf7bdcd10c0b69ea6f0093d5f19feb4f46a977674ddd3c137eb2ed6ca824f0cdc8e4466690ec812378300e73528bbcd4a13e1bb6759546721992425a4b8af751bb1935ccf1f4d318e412224aa1b9562a729ea120f1ca92ce0062b4d6f75a64d0d2dfab2ce77d05fc8ea7b73f49536527fbc06ca0db029f54698d820fc29c3d6a13201a0ddf9098820519eff32b6d160db1d60b039f4176d822d6e4eb13226969fa4a35a1a46cdc5915c4f2afade7da68451b7edc6f20f21978dcb16cbc458051cd225bbf4077d171d6c2d47935c1377e84fa9a19b0fefa7f04015f3fb8d4e95e81ed7d8aae0ed46d1d6dbb589991daa751b52e24b332be20eb8e5274b3b8c69755ac64e56f8710b6bb84b1437c6e6458f8f3eb58373c3df41f84ce563fa257da81e5b7f14003c9905fd5113aba446f75c8cf2d1b0966789a2ba746f911e9a1cc4ae427916d47eadedd95d103b5f650906c911ec40b1bf2aa6b4d767d520c04d461a489b70c18b80c82f7a57409c0085a4be233aa3a9a9f3839e18b2f64d32fc5b39597e66db4b1484dee84da0dd13f4e10d76949df633d0c3f2798ad2af6bd78e8959ad0f17ce658af607e6890883c6cdd4d6d8db2255deb4b71883c36164fbc1f0d9528f494a586d47e8152929b353ea78449267030e95869aeec27c70ee5178e7b1645f373f6763a514176ad1c1474db0d0797b730e352ea83db60e2c6472e5982175ca780fb0505a95a3adb853ae5c1377a015a09572fe73896c8edb8cb59596e4175d2699619ebf8fb075f4ee3211622f51afd110886902cb1493fb2aee0fd5e9591fac6bc75d1e01d5241237924e0d843e222f0805bb6cb25780e659b8ea7f5446aba027236fec34a492e00084c95fa0478ccace3691c2ac0d99e733eb6b0ffbc7cf12d072644b4b6512eba5157650f4e7007c9b762e0ab98cc4125d9bfcfc61783b6f5656735694b0a4aa4e3c3f6cb9cd8dfa8e67af2821a9a75d36891fc1967cdde556a35c25e0859d41c223586b4ce4de9d174bdab40cf1d2b328a28d2e1d47710b505c2c2f2b848c4936f4429ebf108b2056aa894bccc29649da708bb9e8667bcb4f8076f8f9e53829c91f2ce4f63f5e10f79abcf4276a9534c83a1e8ead7da7f8a0b41cc809905f65691061d207867c4a49ef3c1429ada4cbd3910c2484b563cc04aeac799926f3f64f5e10de6f743ef8f3629314f3d9069ed447541ead497a9b40f41acd4f55c94b6e804521349444b353b16b3f4039fe3c5c85df7928a0d1da63702c5f293fac7dcaa1c5d7329f1a7258bb0ab27208b395ac0ae4b183731e540fb7c18f8532a084daebd0c798e5ab5363227dfc8b3190682c4c933c18fdfbaa622388dbf1e388f13099f08ed73f45e420a9604219a861f78212e1f5d50a6729956d18aa1011b6aa1f5b9fef3b68804419928166c6d859cd84d2533c64b9f489ae7f88712d85282705a382c8176e21af7d8925b49e12e7272d52e9a138a8639aaa803b571573b39609317a29c2882857f7fcaf369a2fe48d602dc8216763d929eb6ce9614f53d821c70b2a7fca89c52bc96a4e384087a7dc2d8214b939852c79fe85bcf4cba76df4bb53013f2774da289801aea53d9b12700f740be1f62e0290e60d7f8f8e4661f9de7059ad6dd2bd3c36aacef5dba3b733a3f65c771142a21ade2902e8b0b0e55fbba0c2ad7c2bf792542d7ff5ea107a275950c81692df957412f6b4c4cbad89b00dd903e5458faf08f3c4070c3f5912eb66230475b74ec9d191e18539ac5cd62c55b900a290208477418ed6a89c640ddf66ebde7c8baa001d4ebcf0822dbdddc46d556b69dafb170dfaecb0318bfcdf0bee66d47451deed636eced72db0486e7fee97c25ab50a542e33a070e2513995269372417b02020d6ded8646a0bc9c36bcbc570f4c2c01d4af55bfde1e7a20f2337a2bbf22e3b20de02f874a8180a894eac8d1297ba80211a6555c5d5e880ea5c4f02fb1493950b08d2419e0f060ea4dd64c914f79f011a763cbc422612bc19a69e26c145bab55a08894d4e8ea44a203ae60935a2f056efa8487d3924ece0e35bb449c956680d197b53f14b290c2d840e033461d5414671983ded386a3093f2dc659ea3b7e85fb3df76beefb3db4c7645f3d8eb819496803b9a48aadca4d88a1e3556647bc685bbaf558e60234e21e4c8efb9337746903cdb62c7d5454d5e07c269a60c23fe33fd800e939fb94cc9cd1a5c3765c08b0950a112515b158b95c61a36fd7eb7a4976ed79acfcf446befe839f2f79dad5355e7c137b436e2082282925954c54a1f56b43f0668cde18922d20b26d178b38e1909e94cf7db7e31e1cf06c3ff180ce549a2f4572bde1792d0b696a9d9c0ef7b7350255cfc5f53b5a997a08a822094696fdb9f72e4acd892982e5cb36f427471c2c76b7589a3e82d5c38b7fa57d3fa6b4e858de7092f48a76120570a7b02f28ba766a054455c2664c2161390c0a3d632226fcf9771474cd2dfb805905b5a5c17b8d7db6d92675c78415d2f55100e501d849d8d92247a9845d14909f49119152ecff64518c69c41eda50a7e87f977e2d03d3a323647c3fc03eb2e5454685e8f99fa63f851719b8fa2881f3ceb257b813f449bd7283e1b98478b3a213a593d300414625415f19b09f962e2264c0f1e8986f0178f7ea0098d87faf95a427ad57326d4b2ec98d32375b7d81edb5060900ba5da15c3fc3ebe504d8a023e5f904ae7b1e7115bf9f3da3d334394e650f18eabe5ed7e8e325f60097e227b2a6543a09def2e762016076eaca4acdcda7191a6f7d5a4f1aa390f4ed403823c2bd6b645bbf22c252c1cb7696965784329c19307fec170e38bec871b6718a6444cd7eaa23e0af1d3006e5bb37e1cab38792cf5e00003fdb860d68b41e17711182583111e115f69071dbe79b5b4081ac501ad69064d77391767ffa5a798ffd4841c4a967ee001a91939daf332e5d49044d2b17271617d95065018d684f0192dc2f805c3a644f466ce8dacb881c7413e99d809e3786265886a265a9b9a0d72dfcb4fcd65e4a5f866ea4ad74a96eab5c9cacd6ac0052e6b59d3c954e760acfb280982b7476b96cf018bcc033fdc113b8f84632593b1c09cdb1eb56bd90314f0ffdf562bfc6170fffb732c8e8ed862d99c54bfe2666216361516f46f8e22598e47be59e61716a80cc953a517516f10a5511f27511625215707588c78ffc259e4599e383932a48ca177b20c4d8c55d8d9336b77c832d07e11e373cef020837dfe3f687cbb83dac529d86114e727a5d9a587aa520334d6590e6f576f64382dfb9dd398ec33833405d1fec82f9e4b3bc73c19d302fb60434cf7f77b26c23d5ce9f503f129784f63546ebea9cae7e76de3b6788ac15f9fbabd0e8901f29124da858ade5c29d6a2938d4620668fd90163049af59fd627c32aa9d432d2b3073352270632f5436c267380a54bed9abe8e894f3dcb20a11cf07de336ad2ca347cb3262ebef3daebaf6822ccf002eb22647d7b591f233f745672facda6a575f6139c0383f1dc298c9927e892ae534a041412879098e0f6c35c1cbcfcb893a8f75ed272d2ac8091caa54488ae5d4541c60739d6cee6b91c6debe0605d402846f0aa69372315288de Tìm hiểu về Fernet cipher, ta nhận thấy rằng Fernet token có dạng sau 1token = urlsafe_b64encode(Version ‖ Timestamp ‖ IV ‖ Ciphertext ‖ HMAC) Trong đó Version là byte đầu tiên và bắt đầu bằng 0x80. Với hint từ @m1dm4n, ta biết rằng 64 bytes đầu tiên gây ra collision, và encrypted img bắt đầu từ bytes thứ 65 trở đi. Sử dụng gợi ý từ file key_gen.py, sau nhiều lần thử, str1 dẫn đến key đúng là 64 bit đầu tiên: 14dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2 Với bất kỳ đoạn encrypted_img nào ta cũng có thể tìm về img chứa flag ban đầu. Sử dụng key đã tìm được để giải mã encrypted_img, ta thu được 1 đoạn hex bắt đầu là 89504e47, đây chính là header của file png tiêu chuẩn: Ghi đoạn hex vừa rồi vào file, ta thu được file ảnh: 1p_ctf{60_N0T_u53_md5_f0r_h4sh1n6_p455wor55}","link":"/2023/pragyan-ctf-2023-write-ups/"}],"tags":[{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"WriteUp","slug":"WriteUp","link":"/tags/WriteUp/"},{"name":"NSUCRYPTO","slug":"NSUCRYPTO","link":"/tags/NSUCRYPTO/"}],"categories":[{"name":"CTF Write-ups","slug":"CTF-Write-ups","link":"/categories/CTF-Write-ups/"},{"name":"NSUCRYPTO","slug":"NSUCRYPTO","link":"/categories/NSUCRYPTO/"}],"pages":[{"title":"About me","text":"Moscow, ngày 12 tháng 2 năm 2022 Xin chào bạn đã đến với blog tự học Cryptography của mình! Blog này là nơi mình chia sẻ kiến thức, tự học thông qua tìm hiểu và tham khảo các bài write-up có sẵn trên mạng. Mình cũng sẽ viết write-up bằng tiếng việt ở đây. Về kiến thức nền tảng: Toán học: mình đã có kiến thức nền tảng về các môn toán dùng trong mật mã: Đại số, Giải tích, Xác suất, Lý thuyết số, Lý thuyết Automat. Mật mã học: mình đã được học và làm quen với các loại mã cổ điển như Caesa, Vigenèr, …; một số mật mã khối như AES, SHARK,… . Tuy nhiên việc học mới chỉ dừng lại ở lý thuyết, chưa đi vào thực tế như ở các cuộc thi CTF. Lập trình: mình đã có nền tảng học lập trình C/C++, hiện nay mình đang học thêm ngôn ngữ Python để có thể đọc và hiểu được đề bài trong các cuộc thi CTF. Do mình đang còn là sinh viên, khối lượng học tập trên trường cũng khá lớn nên có thể không sử dụng blog thường xuyên được. Nếu có bất cứ yêu cầu / thắc mắc / giúp đỡ về những write-up của mình, hãy liên hệ với mình qua email phía dưới. Hiện tại mình cũng mới tập chơi CTF, kinh nghiệm còn yếu nên mong muốn được tham gia vào 1 team CTF để được cọ xát, học hỏi thêm. Hy vọng mình sẽ tìm được trong 1 ngày không xa :D.","link":"/about/index.html"},{"title":"Tools","text":"Compilers Tools Detail OneCompilerPy Python Online Compiler Cryptography Tools Detail B64Decoder BASE64 Decode and Encode dCodeFr A collection of tools to help solve ciphers, mathematics, puzzles, etc Guballa Vigenère Solver quipqiup Cryptoquip and cryptogram solver FactorDB A database of factorised numbernumbers Alpertron Integer factorization calculator Steganography Tools Detail FutureBoy Steganographic Decoder MagicEye Magic Eye Solver / Viewer AperiSolve Layer analysis on image","link":"/tools/index.html"}]}